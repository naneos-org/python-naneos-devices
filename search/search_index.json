{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to naneos-devices docs","text":"<p>This documentation is currently being built. In the API Reference section, you will find the generated documentation based on the source code.</p>"},{"location":"#build-this-documentation-locally","title":"Build this documentation locally","text":"<ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> </ul>"},{"location":"#coming-soon","title":"Coming soon","text":"<p>lorem ipsen ...</p>"},{"location":"user-guide/raspberry-pi-setup/","title":"Raspberry Pi Setup","text":""},{"location":"user-guide/raspberry-pi-setup/#basic-setup-of-the-raspberry","title":"Basic Setup of the Raspberry","text":"<p>With the Raspberry Pi Imager install the desired Raspberry Pi Os Version on a SD-Card. If your system becomes headless, then you need to have SSH connection to the raspberry. Later on we need to use the terminal on the Raspberry Pi.</p> <p>Now put the SD-Card into the Raspberry Pi and boot for the first time. To bring you system up to date I would run the following 3 commands and reboot the raspberry afterweards.</p> <pre><code>sudo apt update\nsudo apt full-upgrade\nsudo apt autoremove\nsudo reboot now\n</code></pre>"},{"location":"user-guide/raspberry-pi-setup/#installation-of-python-and-pip","title":"Installation of Python and Pip","text":"<p>Install python and pip with the following command:</p> <pre><code>sudo apt install python3-full python3-pip\n</code></pre>"},{"location":"user-guide/raspberry-pi-setup/#installation-of-the-naneos-package-in-an-virtual-environment","title":"Installation of the Naneos Package in an virtual environment","text":"<p>Create a folder, where you want to execute the naneos Manager and go into this folder.</p> <pre><code>mkdir naneos-uploader\ncd naneos-uploader\n</code></pre> <p>Now we create the virtual environment in an hidden folder called .venv:</p> <pre><code>python -m venv .venv\n</code></pre> <p>Now we activate the virtual environment and install the naneos package that we need for our uploader.</p> <pre><code>source .venv/bin/activate\npip install naneos-devices\n</code></pre> <p>After the installation we can exit the virtual environment.</p> <pre><code>deactivate\n</code></pre>"},{"location":"user-guide/raspberry-pi-setup/#creation-of-the-uploader-script","title":"Creation of the uploader script:","text":"<p>Create a script and copy in the following content.</p> <pre><code>vim uploader-script.py\n</code></pre> <pre><code>#!/home/pi/naneos-uploader/.venv/bin/python\n\nimport signal\nimport time\n\nfrom naneos.manager import NaneosDeviceManager\n\nrunning = True  # global flag to control the main loop\n\n\ndef handle_signal(signum, frame):\n    global running\n    running = False\n\n\n# register signal handlers for SIGTERM and SIGINT\nsignal.signal(signal.SIGTERM, handle_signal)\nsignal.signal(signal.SIGINT, handle_signal)\n\n\ndef rp_service_main() -&gt; None:\n    manager = NaneosDeviceManager(\n        use_serial=True, use_ble=True, upload_active=True, gathering_interval_seconds=30\n    )\n    manager.start()\n\n    try:\n        while running:\n            remaining = manager.get_seconds_until_next_upload()\n\n            slept = 0\n            while running and slept &lt; remaining + 1:\n                time.sleep(1)\n                slept += 1\n\n            if not running:\n                break\n\n    finally:\n        manager.stop()\n        manager.join()\n\n\nif __name__ == \"__main__\":\n    rp_service_main()\n</code></pre> <p>Now we need to make our script executable mit:</p> <pre><code>chmod +x uploader-script.py\n</code></pre>"},{"location":"user-guide/raspberry-pi-setup/#creation-of-the-service","title":"Creation of the service","text":"<p>First we need to create the service-file:</p> <pre><code>sudo vim /etc/systemd/system/naneos_uploader.service\n</code></pre> <p>Then we can enter the following to link the python file and the service.</p> <pre><code>[Unit]\nDescription=Naneos Uploader Service Example\nAfter=network.target\n\n[Service]\nExecStart=/home/pi/naneos-uploader/uploader-script.py\nWorkingDirectory=/home/pi/naneos-uploader\nStandardOutput=inherit\nStandardError=inherit\nRestart=always\nRestartSec=5\nUser=pi\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Now we need to reload the daemons and enable and start the service:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable naneos_uploader.service\nsudo systemctl start naneos_uploader.service\n</code></pre>"},{"location":"reference/naneos/","title":"naneos","text":""},{"location":"reference/naneos/#naneos","title":"<code>naneos</code>","text":""},{"location":"reference/naneos/iotweb/","title":"iotweb","text":""},{"location":"reference/naneos/iotweb/#naneos.iotweb","title":"<code>naneos.iotweb</code>","text":""},{"location":"reference/naneos/iotweb/#naneos.iotweb.NaneosUploadThread","title":"<code>NaneosUploadThread</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src/naneos/iotweb/naneos_upload_thread.py</code> <pre><code>class NaneosUploadThread(Thread):\n    URL: ClassVar[str] = \"https://hg3zkburji.execute-api.eu-central-1.amazonaws.com/prod/proto/v1\"\n    HEADERS: ClassVar[dict] = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    def __init__(\n        self,\n        data: dict[int, pd.DataFrame],\n        callback: Optional[Callable[[bool], None]],\n    ) -&gt; None:\n        \"\"\"Adding the data that should be uploaded to the database.\n\n        Args:\n            data (dict[int, pd.DataFrame]): Data to upload, where the key is the device serial number and the value is a DataFrame.\n            callback (Optional[Callable[[bool], None]]): Callback function that is called after upload.\n        \"\"\"\n        super().__init__()\n        self.data = data\n        self._callback = callback\n\n    def run(self) -&gt; None:\n        try:\n            ret = self.upload(self.data)\n\n            if self._callback:\n                if ret.status_code == 200:\n                    self._callback(True)\n                else:\n                    self._callback(False)\n        except Exception as e:\n            logger.exception(f\"Error in upload: {e}\")\n            if self._callback:\n                self._callback(False)  # delete data because it was corrupted\n\n    @staticmethod\n    def get_body(upload_string: str) -&gt; str:\n        return f\"\"\"\n            {{\n                \"gateway\": \"python_webhook\",\n                \"data\": \"{upload_string}\",\n                \"published_at\": \"{datetime.datetime.now().isoformat()}\"\n            }}\n            \"\"\"\n\n    @classmethod\n    def upload(cls, data: dict[int, pd.DataFrame]) -&gt; requests.Response:\n        abs_time = int(datetime.datetime.now().timestamp())\n        devices = []\n\n        for sn, df in data.items():\n            # make all inf values in df_p2_pro 0\n            df = df.replace([float(\"inf\"), -float(\"inf\")], 0)\n\n            # detect ms timestamp and convert to s\n            if df.index[0] &gt; 1e12:\n                df.index = df.index / 1e3\n                df.index = df.index.astype(int)\n\n            devices.append(create_proto_device(sn, abs_time, df))\n\n        combined_entry = create_combined_entry(devices=devices, abs_timestamp=abs_time)\n\n        proto_str = combined_entry.SerializeToString()\n        proto_str_base64 = base64.b64encode(proto_str).decode()\n\n        body = cls.get_body(proto_str_base64)\n        r = requests.post(cls.URL, headers=cls.HEADERS, data=body, timeout=10)\n        return r\n</code></pre>"},{"location":"reference/naneos/iotweb/#naneos.iotweb.NaneosUploadThread.__init__","title":"<code>__init__(data, callback)</code>","text":"<p>Adding the data that should be uploaded to the database.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[int, DataFrame]</code> <p>Data to upload, where the key is the device serial number and the value is a DataFrame.</p> required <code>callback</code> <code>Optional[Callable[[bool], None]]</code> <p>Callback function that is called after upload.</p> required Source code in <code>src/naneos/iotweb/naneos_upload_thread.py</code> <pre><code>def __init__(\n    self,\n    data: dict[int, pd.DataFrame],\n    callback: Optional[Callable[[bool], None]],\n) -&gt; None:\n    \"\"\"Adding the data that should be uploaded to the database.\n\n    Args:\n        data (dict[int, pd.DataFrame]): Data to upload, where the key is the device serial number and the value is a DataFrame.\n        callback (Optional[Callable[[bool], None]]): Callback function that is called after upload.\n    \"\"\"\n    super().__init__()\n    self.data = data\n    self._callback = callback\n</code></pre>"},{"location":"reference/naneos/iotweb/#naneos.iotweb.download_from_iotweb","title":"<code>download_from_iotweb(name, serial_number, start, stop, token)</code>","text":"<p>Download your data from influxdb.naneos.ch. 1 Month of data takes about 30 seconds to download and uses about 100 MB of data.</p> <p>You need to have a token to access the data. Ask mario.huegi@naneos.ch for your read token. We kindly ask you to not overuse our server. If you need to download the same data in a recuring pattern, contact us.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the influx bucket.</p> required <code>serial_number</code> <code>str</code> <p>Serial number of your device as string.</p> required <code>start</code> <code>datetime</code> <p>Start date of the data you want to download.</p> required <code>stop</code> <code>datetime</code> <p>End date of the data you want to download.</p> required <code>token</code> <code>str</code> <p>Your read token. Do not push your token to public repositories.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Dataframe with your data.</p> Source code in <code>src/naneos/iotweb/download/downloader.py</code> <pre><code>def download_from_iotweb(\n    name: str, serial_number: str, start: dt.datetime, stop: dt.datetime, token: str\n) -&gt; pd.DataFrame:\n    \"\"\"Download your data from influxdb.naneos.ch.\n    1 Month of data takes about 30 seconds to download and uses about 100 MB of data.\n\n    You need to have a token to access the data.\n    Ask mario.huegi@naneos.ch for your read token.\n    We kindly ask you to not overuse our server.\n    If you need to download the same data in a recuring pattern, contact us.\n\n    Args:\n        name (str): Name of the influx bucket.\n        serial_number (str): Serial number of your device as string.\n        start (dt.datetime): Start date of the data you want to download.\n        stop (dt.datetime): End date of the data you want to download.\n        token (str): Your read token. Do not push your token to public repositories.\n\n    Returns:\n        pd.DataFrame: Dataframe with your data.\n    \"\"\"\n    timestamps = create_start_stop_timestamp(start, stop)\n\n    dfs = []\n\n    with InfluxDBClient(url=URL_INFLUX, org=ORG_INFLUX, token=token) as client:\n        for t1, t2 in timestamps:\n            query = get_query(name, serial_number, t1, t2)\n\n            df = client.query_api().query_data_frame(query)\n\n            if isinstance(df, list):\n                dfs.extend(df)\n            elif isinstance(df, pd.DataFrame):\n                dfs.append(df)\n            else:\n                logger.warning(f\"Unknown type: {type(df)}\")\n\n    df = pd.concat(dfs, axis=0)\n    df.set_index(\"_time\", inplace=True)\n    df.drop([\"result\", \"table\"], axis=1, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/naneos/iotweb/download/","title":"download","text":""},{"location":"reference/naneos/iotweb/download/#naneos.iotweb.download","title":"<code>naneos.iotweb.download</code>","text":""},{"location":"reference/naneos/iotweb/download/downloader/","title":"downloader","text":""},{"location":"reference/naneos/iotweb/download/downloader/#naneos.iotweb.download.downloader","title":"<code>naneos.iotweb.download.downloader</code>","text":""},{"location":"reference/naneos/iotweb/download/downloader/#naneos.iotweb.download.downloader.create_start_stop_timestamp","title":"<code>create_start_stop_timestamp(start_dt, stop_dt)</code>","text":"<p>Returns a list of lists with start stop times in 1 day chunks in unix timesamps</p> Source code in <code>src/naneos/iotweb/download/downloader.py</code> <pre><code>def create_start_stop_timestamp(start_dt: dt.datetime, stop_dt: dt.datetime) -&gt; list:\n    \"\"\"Returns a list of lists with start stop times in 1 day chunks in unix timesamps\"\"\"\n    delta_seconds = 3600 * 24 * 2\n\n    start = int(start_dt.timestamp())\n    stop = int(stop_dt.timestamp())\n\n    start_stop_times = []\n\n    while start &lt; stop - delta_seconds:\n        start_stop_times.append([start, start + delta_seconds])\n        start += delta_seconds\n    start_stop_times.append([start, stop])\n\n    return start_stop_times\n</code></pre>"},{"location":"reference/naneos/iotweb/download/downloader/#naneos.iotweb.download.downloader.download_from_iotweb","title":"<code>download_from_iotweb(name, serial_number, start, stop, token)</code>","text":"<p>Download your data from influxdb.naneos.ch. 1 Month of data takes about 30 seconds to download and uses about 100 MB of data.</p> <p>You need to have a token to access the data. Ask mario.huegi@naneos.ch for your read token. We kindly ask you to not overuse our server. If you need to download the same data in a recuring pattern, contact us.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the influx bucket.</p> required <code>serial_number</code> <code>str</code> <p>Serial number of your device as string.</p> required <code>start</code> <code>datetime</code> <p>Start date of the data you want to download.</p> required <code>stop</code> <code>datetime</code> <p>End date of the data you want to download.</p> required <code>token</code> <code>str</code> <p>Your read token. Do not push your token to public repositories.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Dataframe with your data.</p> Source code in <code>src/naneos/iotweb/download/downloader.py</code> <pre><code>def download_from_iotweb(\n    name: str, serial_number: str, start: dt.datetime, stop: dt.datetime, token: str\n) -&gt; pd.DataFrame:\n    \"\"\"Download your data from influxdb.naneos.ch.\n    1 Month of data takes about 30 seconds to download and uses about 100 MB of data.\n\n    You need to have a token to access the data.\n    Ask mario.huegi@naneos.ch for your read token.\n    We kindly ask you to not overuse our server.\n    If you need to download the same data in a recuring pattern, contact us.\n\n    Args:\n        name (str): Name of the influx bucket.\n        serial_number (str): Serial number of your device as string.\n        start (dt.datetime): Start date of the data you want to download.\n        stop (dt.datetime): End date of the data you want to download.\n        token (str): Your read token. Do not push your token to public repositories.\n\n    Returns:\n        pd.DataFrame: Dataframe with your data.\n    \"\"\"\n    timestamps = create_start_stop_timestamp(start, stop)\n\n    dfs = []\n\n    with InfluxDBClient(url=URL_INFLUX, org=ORG_INFLUX, token=token) as client:\n        for t1, t2 in timestamps:\n            query = get_query(name, serial_number, t1, t2)\n\n            df = client.query_api().query_data_frame(query)\n\n            if isinstance(df, list):\n                dfs.extend(df)\n            elif isinstance(df, pd.DataFrame):\n                dfs.append(df)\n            else:\n                logger.warning(f\"Unknown type: {type(df)}\")\n\n    df = pd.concat(dfs, axis=0)\n    df.set_index(\"_time\", inplace=True)\n    df.drop([\"result\", \"table\"], axis=1, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/naneos/iotweb/naneos_upload_thread/","title":"naneos_upload_thread","text":""},{"location":"reference/naneos/iotweb/naneos_upload_thread/#naneos.iotweb.naneos_upload_thread","title":"<code>naneos.iotweb.naneos_upload_thread</code>","text":""},{"location":"reference/naneos/iotweb/naneos_upload_thread/#naneos.iotweb.naneos_upload_thread.NaneosUploadThread","title":"<code>NaneosUploadThread</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src/naneos/iotweb/naneos_upload_thread.py</code> <pre><code>class NaneosUploadThread(Thread):\n    URL: ClassVar[str] = \"https://hg3zkburji.execute-api.eu-central-1.amazonaws.com/prod/proto/v1\"\n    HEADERS: ClassVar[dict] = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    def __init__(\n        self,\n        data: dict[int, pd.DataFrame],\n        callback: Optional[Callable[[bool], None]],\n    ) -&gt; None:\n        \"\"\"Adding the data that should be uploaded to the database.\n\n        Args:\n            data (dict[int, pd.DataFrame]): Data to upload, where the key is the device serial number and the value is a DataFrame.\n            callback (Optional[Callable[[bool], None]]): Callback function that is called after upload.\n        \"\"\"\n        super().__init__()\n        self.data = data\n        self._callback = callback\n\n    def run(self) -&gt; None:\n        try:\n            ret = self.upload(self.data)\n\n            if self._callback:\n                if ret.status_code == 200:\n                    self._callback(True)\n                else:\n                    self._callback(False)\n        except Exception as e:\n            logger.exception(f\"Error in upload: {e}\")\n            if self._callback:\n                self._callback(False)  # delete data because it was corrupted\n\n    @staticmethod\n    def get_body(upload_string: str) -&gt; str:\n        return f\"\"\"\n            {{\n                \"gateway\": \"python_webhook\",\n                \"data\": \"{upload_string}\",\n                \"published_at\": \"{datetime.datetime.now().isoformat()}\"\n            }}\n            \"\"\"\n\n    @classmethod\n    def upload(cls, data: dict[int, pd.DataFrame]) -&gt; requests.Response:\n        abs_time = int(datetime.datetime.now().timestamp())\n        devices = []\n\n        for sn, df in data.items():\n            # make all inf values in df_p2_pro 0\n            df = df.replace([float(\"inf\"), -float(\"inf\")], 0)\n\n            # detect ms timestamp and convert to s\n            if df.index[0] &gt; 1e12:\n                df.index = df.index / 1e3\n                df.index = df.index.astype(int)\n\n            devices.append(create_proto_device(sn, abs_time, df))\n\n        combined_entry = create_combined_entry(devices=devices, abs_timestamp=abs_time)\n\n        proto_str = combined_entry.SerializeToString()\n        proto_str_base64 = base64.b64encode(proto_str).decode()\n\n        body = cls.get_body(proto_str_base64)\n        r = requests.post(cls.URL, headers=cls.HEADERS, data=body, timeout=10)\n        return r\n</code></pre>"},{"location":"reference/naneos/iotweb/naneos_upload_thread/#naneos.iotweb.naneos_upload_thread.NaneosUploadThread.__init__","title":"<code>__init__(data, callback)</code>","text":"<p>Adding the data that should be uploaded to the database.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[int, DataFrame]</code> <p>Data to upload, where the key is the device serial number and the value is a DataFrame.</p> required <code>callback</code> <code>Optional[Callable[[bool], None]]</code> <p>Callback function that is called after upload.</p> required Source code in <code>src/naneos/iotweb/naneos_upload_thread.py</code> <pre><code>def __init__(\n    self,\n    data: dict[int, pd.DataFrame],\n    callback: Optional[Callable[[bool], None]],\n) -&gt; None:\n    \"\"\"Adding the data that should be uploaded to the database.\n\n    Args:\n        data (dict[int, pd.DataFrame]): Data to upload, where the key is the device serial number and the value is a DataFrame.\n        callback (Optional[Callable[[bool], None]]): Callback function that is called after upload.\n    \"\"\"\n    super().__init__()\n    self.data = data\n    self._callback = callback\n</code></pre>"},{"location":"reference/naneos/logger/","title":"logger","text":""},{"location":"reference/naneos/logger/#naneos.logger","title":"<code>naneos.logger</code>","text":""},{"location":"reference/naneos/logger/custom_logger/","title":"custom_logger","text":""},{"location":"reference/naneos/logger/custom_logger/#naneos.logger.custom_logger","title":"<code>naneos.logger.custom_logger</code>","text":""},{"location":"reference/naneos/manager/","title":"manager","text":""},{"location":"reference/naneos/manager/#naneos.manager","title":"<code>naneos.manager</code>","text":""},{"location":"reference/naneos/manager/#naneos.manager.NaneosDeviceManager","title":"<code>NaneosDeviceManager</code>","text":"<p>               Bases: <code>Thread</code></p> <p>NaneosDeviceManager is a class that manages Naneos devices. It connects and disconnects automatically.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>class NaneosDeviceManager(threading.Thread):\n    \"\"\"\n    NaneosDeviceManager is a class that manages Naneos devices.\n    It connects and disconnects automatically.\n    \"\"\"\n\n    def __init__(\n        self, use_serial=True, use_ble=True, upload_active=True, gathering_interval_seconds=30\n    ) -&gt; None:\n        super().__init__(daemon=True)\n        self._use_serial = use_serial\n        self._use_ble = use_ble\n        self._upload_active = upload_active\n        self._next_upload_time = time.time() + gathering_interval_seconds\n        self.set_gathering_interval_seconds(gathering_interval_seconds)\n\n        self._out_queue: queue.Queue | None = None\n\n        self._stop_event = threading.Event()\n\n        self._manager_serial: PartectorSerialManager | None = None\n        self._manager_ble: PartectorBleManager | None = None\n\n        self._data: dict[int, pd.DataFrame] = {}\n\n        self.upload_blocked_devices: list[int | None] = []\n\n    def use_serial_connections(self, use: bool) -&gt; None:\n        self._use_serial = use\n\n    def use_ble_connections(self, use: bool) -&gt; None:\n        self._use_ble = use\n\n    def get_serial_connection_status(self) -&gt; bool:\n        return self._use_serial\n\n    def get_ble_connection_status(self) -&gt; bool:\n        return self._use_ble\n\n    def get_upload_status(self) -&gt; bool:\n        return self._upload_active\n\n    def set_upload_status(self, active: bool) -&gt; None:\n        self._upload_active = active\n\n    def get_gathering_interval_seconds(self) -&gt; int:\n        return self._gathering_interval_seconds\n\n    def set_gathering_interval_seconds(self, interval: int) -&gt; None:\n        interval = max(10, min(600, interval))\n        logger.info(f\"Setting gathering interval to {interval} seconds.\")\n        self._gathering_interval_seconds = interval\n\n        tmp_next_upload_time = time.time() + self._gathering_interval_seconds\n        self._next_upload_time = min(self._next_upload_time, tmp_next_upload_time)\n\n    def register_output_queue(self, out_queue: queue.Queue) -&gt; None:\n        self._out_queue = out_queue\n\n    def unregister_output_queue(self) -&gt; None:\n        self._out_queue = None\n\n    def run(self) -&gt; None:\n        self._loop()\n\n        # graceful shutdown in any case\n        self._use_serial = False\n        self._loop_serial_manager()\n        self._use_ble = False\n        self._loop_ble_manager()\n\n    def stop(self) -&gt; None:\n        self._stop_event.set()\n\n    def get_connected_serial_devices(self) -&gt; list[str]:\n        \"\"\"\n        Returns a list of connected serial devices.\n        \"\"\"\n        if self._manager_serial is None:\n            return []\n\n        return self._manager_serial.get_connected_device_strings()\n\n    def get_connected_ble_devices(self) -&gt; list[str]:\n        \"\"\"\n        Returns a list of connected BLE devices.\n        \"\"\"\n        if self._manager_ble is None:\n            return []\n\n        return self._manager_ble.get_connected_device_strings()\n\n    def get_seconds_until_next_upload(self) -&gt; float:\n        \"\"\"\n        Returns the number of seconds until the next upload.\n        This is used to determine when to upload data.\n        \"\"\"\n        return max(0, self._next_upload_time - time.time())\n\n    def _loop_serial_manager(self) -&gt; None:\n        # normal operation\n        if (\n            isinstance(self._manager_serial, PartectorSerialManager)\n            and self._manager_serial.is_alive()\n        ):\n            self.upload_blocked_devices = self._manager_serial.get_gain_test_activating_devices()\n            data_serial = self._manager_serial.get_data()\n            self._data = add_to_existing_naneos_data(self._data, data_serial)\n        # starting\n        if self._manager_serial is None and self._use_serial:\n            logger.info(\"Starting serial manager...\")\n            self._manager_serial = PartectorSerialManager()\n            self._manager_serial.start()\n        # stopping\n        if isinstance(self._manager_serial, PartectorSerialManager) and not self._use_serial:\n            logger.info(\"Stopping serial manager...\")\n            self._manager_serial.stop()\n            self._manager_serial.join()\n            self._manager_serial = None\n\n    def _loop_ble_manager(self) -&gt; None:\n        # normal operation\n        if isinstance(self._manager_ble, PartectorBleManager) and self._manager_ble.is_alive():\n            data_ble = self._manager_ble.get_data()\n            self._data = add_to_existing_naneos_data(self._data, data_ble)\n        # starting\n        if self._manager_ble is None and self._use_ble:\n            logger.info(\"Starting BLE manager...\")\n            self._manager_ble = PartectorBleManager()\n            self._manager_ble.start()\n        # stopping\n        if isinstance(self._manager_ble, PartectorBleManager) and not self._use_ble:\n            logger.info(\"Stopping BLE manager...\")\n            self._manager_ble.stop()\n            self._manager_ble.join()\n            self._manager_ble = None\n\n    def _loop(self) -&gt; None:\n        self._next_upload_time = time.time() + self._gathering_interval_seconds\n\n        while not self._stop_event.is_set():\n            try:\n                time.sleep(1)\n\n                self._loop_serial_manager()\n                self._loop_ble_manager()\n\n                # remove entries from _data that is in upload_blocked_devices\n                for blocked_sn in self.upload_blocked_devices:\n                    if blocked_sn in self._data:\n                        del self._data[blocked_sn]\n\n                if time.time() &gt;= self._next_upload_time:\n                    self._next_upload_time = time.time() + self._gathering_interval_seconds\n\n                    serial_connected_sns: list[int | None] = []\n                    if self._use_serial and self._manager_serial is not None:\n                        serial_connected_sns = self._manager_serial.get_connected_serial_numbers()\n\n                    upload_data = sort_and_clean_naneos_data(self._data, serial_connected_sns)\n                    self._data = {}\n\n                    if isinstance(self._out_queue, queue.Queue):\n                        self._out_queue.put(upload_data)\n\n                    if self._upload_active:\n                        uploader = NaneosUploadThread(\n                            upload_data,\n                            callback=lambda success: logger.info(f\"Upload success: {success}\"),\n                        )\n                        uploader.start()\n                        uploader.join()\n\n            except Exception as e:\n                logger.exception(f\"DeviceManager loop exception: {e}\")\n</code></pre>"},{"location":"reference/naneos/manager/#naneos.manager.NaneosDeviceManager.get_connected_ble_devices","title":"<code>get_connected_ble_devices()</code>","text":"<p>Returns a list of connected BLE devices.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_connected_ble_devices(self) -&gt; list[str]:\n    \"\"\"\n    Returns a list of connected BLE devices.\n    \"\"\"\n    if self._manager_ble is None:\n        return []\n\n    return self._manager_ble.get_connected_device_strings()\n</code></pre>"},{"location":"reference/naneos/manager/#naneos.manager.NaneosDeviceManager.get_connected_serial_devices","title":"<code>get_connected_serial_devices()</code>","text":"<p>Returns a list of connected serial devices.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_connected_serial_devices(self) -&gt; list[str]:\n    \"\"\"\n    Returns a list of connected serial devices.\n    \"\"\"\n    if self._manager_serial is None:\n        return []\n\n    return self._manager_serial.get_connected_device_strings()\n</code></pre>"},{"location":"reference/naneos/manager/#naneos.manager.NaneosDeviceManager.get_seconds_until_next_upload","title":"<code>get_seconds_until_next_upload()</code>","text":"<p>Returns the number of seconds until the next upload. This is used to determine when to upload data.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_seconds_until_next_upload(self) -&gt; float:\n    \"\"\"\n    Returns the number of seconds until the next upload.\n    This is used to determine when to upload data.\n    \"\"\"\n    return max(0, self._next_upload_time - time.time())\n</code></pre>"},{"location":"reference/naneos/manager/naneos_device_manager/","title":"naneos_device_manager","text":""},{"location":"reference/naneos/manager/naneos_device_manager/#naneos.manager.naneos_device_manager","title":"<code>naneos.manager.naneos_device_manager</code>","text":""},{"location":"reference/naneos/manager/naneos_device_manager/#naneos.manager.naneos_device_manager.NaneosDeviceManager","title":"<code>NaneosDeviceManager</code>","text":"<p>               Bases: <code>Thread</code></p> <p>NaneosDeviceManager is a class that manages Naneos devices. It connects and disconnects automatically.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>class NaneosDeviceManager(threading.Thread):\n    \"\"\"\n    NaneosDeviceManager is a class that manages Naneos devices.\n    It connects and disconnects automatically.\n    \"\"\"\n\n    def __init__(\n        self, use_serial=True, use_ble=True, upload_active=True, gathering_interval_seconds=30\n    ) -&gt; None:\n        super().__init__(daemon=True)\n        self._use_serial = use_serial\n        self._use_ble = use_ble\n        self._upload_active = upload_active\n        self._next_upload_time = time.time() + gathering_interval_seconds\n        self.set_gathering_interval_seconds(gathering_interval_seconds)\n\n        self._out_queue: queue.Queue | None = None\n\n        self._stop_event = threading.Event()\n\n        self._manager_serial: PartectorSerialManager | None = None\n        self._manager_ble: PartectorBleManager | None = None\n\n        self._data: dict[int, pd.DataFrame] = {}\n\n        self.upload_blocked_devices: list[int | None] = []\n\n    def use_serial_connections(self, use: bool) -&gt; None:\n        self._use_serial = use\n\n    def use_ble_connections(self, use: bool) -&gt; None:\n        self._use_ble = use\n\n    def get_serial_connection_status(self) -&gt; bool:\n        return self._use_serial\n\n    def get_ble_connection_status(self) -&gt; bool:\n        return self._use_ble\n\n    def get_upload_status(self) -&gt; bool:\n        return self._upload_active\n\n    def set_upload_status(self, active: bool) -&gt; None:\n        self._upload_active = active\n\n    def get_gathering_interval_seconds(self) -&gt; int:\n        return self._gathering_interval_seconds\n\n    def set_gathering_interval_seconds(self, interval: int) -&gt; None:\n        interval = max(10, min(600, interval))\n        logger.info(f\"Setting gathering interval to {interval} seconds.\")\n        self._gathering_interval_seconds = interval\n\n        tmp_next_upload_time = time.time() + self._gathering_interval_seconds\n        self._next_upload_time = min(self._next_upload_time, tmp_next_upload_time)\n\n    def register_output_queue(self, out_queue: queue.Queue) -&gt; None:\n        self._out_queue = out_queue\n\n    def unregister_output_queue(self) -&gt; None:\n        self._out_queue = None\n\n    def run(self) -&gt; None:\n        self._loop()\n\n        # graceful shutdown in any case\n        self._use_serial = False\n        self._loop_serial_manager()\n        self._use_ble = False\n        self._loop_ble_manager()\n\n    def stop(self) -&gt; None:\n        self._stop_event.set()\n\n    def get_connected_serial_devices(self) -&gt; list[str]:\n        \"\"\"\n        Returns a list of connected serial devices.\n        \"\"\"\n        if self._manager_serial is None:\n            return []\n\n        return self._manager_serial.get_connected_device_strings()\n\n    def get_connected_ble_devices(self) -&gt; list[str]:\n        \"\"\"\n        Returns a list of connected BLE devices.\n        \"\"\"\n        if self._manager_ble is None:\n            return []\n\n        return self._manager_ble.get_connected_device_strings()\n\n    def get_seconds_until_next_upload(self) -&gt; float:\n        \"\"\"\n        Returns the number of seconds until the next upload.\n        This is used to determine when to upload data.\n        \"\"\"\n        return max(0, self._next_upload_time - time.time())\n\n    def _loop_serial_manager(self) -&gt; None:\n        # normal operation\n        if (\n            isinstance(self._manager_serial, PartectorSerialManager)\n            and self._manager_serial.is_alive()\n        ):\n            self.upload_blocked_devices = self._manager_serial.get_gain_test_activating_devices()\n            data_serial = self._manager_serial.get_data()\n            self._data = add_to_existing_naneos_data(self._data, data_serial)\n        # starting\n        if self._manager_serial is None and self._use_serial:\n            logger.info(\"Starting serial manager...\")\n            self._manager_serial = PartectorSerialManager()\n            self._manager_serial.start()\n        # stopping\n        if isinstance(self._manager_serial, PartectorSerialManager) and not self._use_serial:\n            logger.info(\"Stopping serial manager...\")\n            self._manager_serial.stop()\n            self._manager_serial.join()\n            self._manager_serial = None\n\n    def _loop_ble_manager(self) -&gt; None:\n        # normal operation\n        if isinstance(self._manager_ble, PartectorBleManager) and self._manager_ble.is_alive():\n            data_ble = self._manager_ble.get_data()\n            self._data = add_to_existing_naneos_data(self._data, data_ble)\n        # starting\n        if self._manager_ble is None and self._use_ble:\n            logger.info(\"Starting BLE manager...\")\n            self._manager_ble = PartectorBleManager()\n            self._manager_ble.start()\n        # stopping\n        if isinstance(self._manager_ble, PartectorBleManager) and not self._use_ble:\n            logger.info(\"Stopping BLE manager...\")\n            self._manager_ble.stop()\n            self._manager_ble.join()\n            self._manager_ble = None\n\n    def _loop(self) -&gt; None:\n        self._next_upload_time = time.time() + self._gathering_interval_seconds\n\n        while not self._stop_event.is_set():\n            try:\n                time.sleep(1)\n\n                self._loop_serial_manager()\n                self._loop_ble_manager()\n\n                # remove entries from _data that is in upload_blocked_devices\n                for blocked_sn in self.upload_blocked_devices:\n                    if blocked_sn in self._data:\n                        del self._data[blocked_sn]\n\n                if time.time() &gt;= self._next_upload_time:\n                    self._next_upload_time = time.time() + self._gathering_interval_seconds\n\n                    serial_connected_sns: list[int | None] = []\n                    if self._use_serial and self._manager_serial is not None:\n                        serial_connected_sns = self._manager_serial.get_connected_serial_numbers()\n\n                    upload_data = sort_and_clean_naneos_data(self._data, serial_connected_sns)\n                    self._data = {}\n\n                    if isinstance(self._out_queue, queue.Queue):\n                        self._out_queue.put(upload_data)\n\n                    if self._upload_active:\n                        uploader = NaneosUploadThread(\n                            upload_data,\n                            callback=lambda success: logger.info(f\"Upload success: {success}\"),\n                        )\n                        uploader.start()\n                        uploader.join()\n\n            except Exception as e:\n                logger.exception(f\"DeviceManager loop exception: {e}\")\n</code></pre>"},{"location":"reference/naneos/manager/naneos_device_manager/#naneos.manager.naneos_device_manager.NaneosDeviceManager.get_connected_ble_devices","title":"<code>get_connected_ble_devices()</code>","text":"<p>Returns a list of connected BLE devices.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_connected_ble_devices(self) -&gt; list[str]:\n    \"\"\"\n    Returns a list of connected BLE devices.\n    \"\"\"\n    if self._manager_ble is None:\n        return []\n\n    return self._manager_ble.get_connected_device_strings()\n</code></pre>"},{"location":"reference/naneos/manager/naneos_device_manager/#naneos.manager.naneos_device_manager.NaneosDeviceManager.get_connected_serial_devices","title":"<code>get_connected_serial_devices()</code>","text":"<p>Returns a list of connected serial devices.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_connected_serial_devices(self) -&gt; list[str]:\n    \"\"\"\n    Returns a list of connected serial devices.\n    \"\"\"\n    if self._manager_serial is None:\n        return []\n\n    return self._manager_serial.get_connected_device_strings()\n</code></pre>"},{"location":"reference/naneos/manager/naneos_device_manager/#naneos.manager.naneos_device_manager.NaneosDeviceManager.get_seconds_until_next_upload","title":"<code>get_seconds_until_next_upload()</code>","text":"<p>Returns the number of seconds until the next upload. This is used to determine when to upload data.</p> Source code in <code>src/naneos/manager/naneos_device_manager.py</code> <pre><code>def get_seconds_until_next_upload(self) -&gt; float:\n    \"\"\"\n    Returns the number of seconds until the next upload.\n    This is used to determine when to upload data.\n    \"\"\"\n    return max(0, self._next_upload_time - time.time())\n</code></pre>"},{"location":"reference/naneos/partector/","title":"partector","text":""},{"location":"reference/naneos/partector/#naneos.partector","title":"<code>naneos.partector</code>","text":""},{"location":"reference/naneos/partector/#naneos.partector.PartectorSerialManager","title":"<code>PartectorSerialManager</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>class PartectorSerialManager(threading.Thread):\n    def __init__(self) -&gt; None:\n        super().__init__(daemon=True)\n        self._stop_event = threading.Event()\n\n        self._data: dict[int, pd.DataFrame] = {}\n\n        self._connected_p1: dict[str, Partector1] = {}\n        self._connected_p2: dict[str, Partector2] = {}\n        self._connected_p2_pro: dict[str, Partector2Pro] = {}\n\n    def get_data(self) -&gt; dict[int, pd.DataFrame]:\n        \"\"\"Fetches the data from all connected devices and returns it.\"\"\"\n        self._fetch_data()\n        data = self._data\n        self._data = {}\n        return data\n\n    def _fetch_data(self):\n        \"\"\"Returns the data dictionary and deletes it.\"\"\"\n        for port in list(self._connected_p1.keys()):\n            points = self._connected_p1[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n        for port in list(self._connected_p2.keys()):\n            points = self._connected_p2[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n        for port in list(self._connected_p2_pro.keys()):\n            points = self._connected_p2_pro[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n    def stop(self) -&gt; None:\n        self._stop_event.set()\n\n    def run(self) -&gt; None:\n        try:\n            self._manager_loop()\n        except RuntimeError as e:\n            logger.exception(f\"SerialManager loop exited with: {e}\")\n\n    def get_connected_device_strings(self) -&gt; list[str]:\n        \"\"\"Returns a list of connected device strings.\"\"\"\n        p1_strings = [f\"SN{p._sn} (P1)\" for port, p in self._connected_p1.items()]\n        p2_strings = [f\"SN{p._sn} (P2)\" for port, p in self._connected_p2.items()]\n        p2_pro_strings = [f\"SN{p._sn} (P2 Pro)\" for port, p in self._connected_p2_pro.items()]\n\n        return p1_strings + p2_strings + p2_pro_strings\n\n    def get_gain_test_activating_devices(self) -&gt; list[int | None]:\n        \"\"\"Returns a list of serial numbers of devices with gain test active.\"\"\"\n        # _wait_with_data_output_until is larger than time.time()\n        p2_gain_test = [\n            p._sn\n            for p in self._connected_p2.values()\n            if p._wait_with_data_output_until &gt; time.time()\n        ]\n        p2_pro_gain_test = [\n            p._sn\n            for p in self._connected_p2_pro.values()\n            if p._wait_with_data_output_until &gt; time.time()\n        ]\n\n        return p2_gain_test + p2_pro_gain_test\n\n    def get_connected_addresses(self) -&gt; list[str]:\n        p1_ports = list(self._connected_p1.keys())\n        p2_ports = list(self._connected_p2.keys())\n        p2_pro_ports = list(self._connected_p2_pro.keys())\n\n        return p1_ports + p2_ports + p2_pro_ports\n\n    def get_connected_serial_numbers(self) -&gt; list[int | None]:\n        p1_serials = [p._sn for p in self._connected_p1.values()]\n        p2_serials = [p._sn for p in self._connected_p2.values()]\n        p2_pro_serials = [p._sn for p in self._connected_p2_pro.values()]\n\n        return p1_serials + p2_serials + p2_pro_serials\n\n    def _manager_loop(self) -&gt; None:\n        while not self._stop_event.is_set():\n            try:\n                possible_ports = scan_for_serial_partectors(\n                    ports_exclude=self.get_connected_addresses()\n                )\n\n                self._disconnect_unplugged_ports()\n                self._connect_to_new_ports(possible_ports)\n\n                self._fetch_data()  # Fetch data from all connected devices\n\n                time.sleep(1.0)  # Sleep to avoid busy waiting\n\n            except Exception as e:\n                logger.exception(f\"Error in serial manager loop: {e}\")\n\n        self._close_all_ports()\n\n    def _disconnect_unplugged_ports(self) -&gt; None:\n        \"\"\"Disconnects all ports that are not in the possible_ports dictionary.\"\"\"\n        # Disconnect P1 ports\n        for port in list(self._connected_p1.keys()):\n            if not self._connected_p1[port]._connected:\n                self._connected_p1[port].close()\n                self._connected_p1.pop(port, None)\n\n        # Disconnect P2 ports\n        for port in list(self._connected_p2.keys()):\n            if not self._connected_p2[port]._connected:\n                self._connected_p2[port].close()\n                self._connected_p2.pop(port, None)\n\n        # Disconnect P2 Pro ports\n        for port in list(self._connected_p2_pro.keys()):\n            if not self._connected_p2_pro[port]._connected:\n                print(f\"Disconnecting P2 Pro port: {port}\")\n                self._connected_p2_pro[port].close()\n                self._connected_p2_pro.pop(port, None)\n\n    def _connect_to_new_ports(self, possible_ports: dict[str, dict[int, str]]) -&gt; None:\n        p1_ports = possible_ports[\"P1\"].values()\n        p2_ports = possible_ports[\"P2\"].values()\n        p2pro_ports = possible_ports[\"P2pro\"].values()\n\n        for port in p1_ports:\n            self._connected_p1[port] = Partector1(port=port)\n        for port in p2_ports:\n            self._connected_p2[port] = Partector2(port=port)\n        for port in p2pro_ports:\n            self._connected_p2_pro[port] = Partector2Pro(port=port)\n\n    def _close_all_ports(self) -&gt; None:\n        for port in list(self._connected_p1.keys()):\n            self._connected_p1[port].close()\n            self._connected_p1.pop(port, None)\n\n        for port in list(self._connected_p2.keys()):\n            self._connected_p2[port].close()\n            self._connected_p2.pop(port, None)\n\n        for port in list(self._connected_p2_pro.keys()):\n            self._connected_p2_pro[port].close()\n            self._connected_p2_pro.pop(port, None)\n</code></pre>"},{"location":"reference/naneos/partector/#naneos.partector.PartectorSerialManager.get_connected_device_strings","title":"<code>get_connected_device_strings()</code>","text":"<p>Returns a list of connected device strings.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_connected_device_strings(self) -&gt; list[str]:\n    \"\"\"Returns a list of connected device strings.\"\"\"\n    p1_strings = [f\"SN{p._sn} (P1)\" for port, p in self._connected_p1.items()]\n    p2_strings = [f\"SN{p._sn} (P2)\" for port, p in self._connected_p2.items()]\n    p2_pro_strings = [f\"SN{p._sn} (P2 Pro)\" for port, p in self._connected_p2_pro.items()]\n\n    return p1_strings + p2_strings + p2_pro_strings\n</code></pre>"},{"location":"reference/naneos/partector/#naneos.partector.PartectorSerialManager.get_data","title":"<code>get_data()</code>","text":"<p>Fetches the data from all connected devices and returns it.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_data(self) -&gt; dict[int, pd.DataFrame]:\n    \"\"\"Fetches the data from all connected devices and returns it.\"\"\"\n    self._fetch_data()\n    data = self._data\n    self._data = {}\n    return data\n</code></pre>"},{"location":"reference/naneos/partector/#naneos.partector.PartectorSerialManager.get_gain_test_activating_devices","title":"<code>get_gain_test_activating_devices()</code>","text":"<p>Returns a list of serial numbers of devices with gain test active.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_gain_test_activating_devices(self) -&gt; list[int | None]:\n    \"\"\"Returns a list of serial numbers of devices with gain test active.\"\"\"\n    # _wait_with_data_output_until is larger than time.time()\n    p2_gain_test = [\n        p._sn\n        for p in self._connected_p2.values()\n        if p._wait_with_data_output_until &gt; time.time()\n    ]\n    p2_pro_gain_test = [\n        p._sn\n        for p in self._connected_p2_pro.values()\n        if p._wait_with_data_output_until &gt; time.time()\n    ]\n\n    return p2_gain_test + p2_pro_gain_test\n</code></pre>"},{"location":"reference/naneos/partector/blueprints/","title":"blueprints","text":""},{"location":"reference/naneos/partector/blueprints/#naneos.partector.blueprints","title":"<code>naneos.partector.blueprints</code>","text":""},{"location":"reference/naneos/partector/partector1/","title":"partector1","text":""},{"location":"reference/naneos/partector/partector1/#naneos.partector.partector1","title":"<code>naneos.partector.partector1</code>","text":""},{"location":"reference/naneos/partector/partector1/#naneos.partector.partector1.Partector1","title":"<code>Partector1</code>","text":"<p>               Bases: <code>PartectorBluePrint</code></p> Source code in <code>src/naneos/partector/partector1.py</code> <pre><code>class Partector1(PartectorBluePrint):\n    def __init__(\n        self, serial_number: Optional[int] = None, port: Optional[str] = None, verb_freq: int = 1\n    ) -&gt; None:\n        super().__init__(serial_number, port, verb_freq)\n\n    def _init_serial_data_structure(self) -&gt; None:\n        self.device_type = NaneosDeviceDataPoint.DEV_TYPE_P1\n        self._data_structure = PARTECTOR1_DATA_STRUCTURE_V_LEGACY\n        self._legacy_data_structure = True\n\n    def _set_verbose_freq(self, freq: int) -&gt; None:\n        \"\"\"\n        Set the frequency of the verbose output.\n\n        :param int freq: Frequency of the verbose output in Hz. (0: off, 1: 1Hz, 2: 10Hz, 3: 100Hz)\n        \"\"\"\n\n        if freq &lt; 0 or freq &gt; 3:\n            raise ValueError(\"Frequency must be between 0 and 3!\")\n\n        self._write_line(f\"X000{freq}!\")\n</code></pre>"},{"location":"reference/naneos/partector/partector2/","title":"partector2","text":""},{"location":"reference/naneos/partector/partector2/#naneos.partector.partector2","title":"<code>naneos.partector.partector2</code>","text":""},{"location":"reference/naneos/partector/partector2/#naneos.partector.partector2.Partector2","title":"<code>Partector2</code>","text":"<p>               Bases: <code>PartectorBluePrint</code></p> Source code in <code>src/naneos/partector/partector2.py</code> <pre><code>class Partector2(PartectorBluePrint):\n    def __init__(\n        self,\n        serial_number: Optional[int] = None,\n        port: Optional[str] = None,\n        verb_freq: int = 1,\n        gain_test_active: bool = True,\n        output_pulse_diagnostics: bool = True,\n    ) -&gt; None:\n        self._GAIN_TEST_ACTIVE = gain_test_active\n        self._OUTPUT_PULSE_DIAGNOSTICS = output_pulse_diagnostics\n        super().__init__(serial_number, port, verb_freq, \"P2\")\n\n    def _init_serial_data_structure(self) -&gt; None:\n        self.device_type = NaneosDeviceDataPoint.DEV_TYPE_P2\n\n        if self._fw in [265, 275]:\n            self._data_structure = PARTECTOR2_DATA_STRUCTURE_V265_V275\n            logger.info(f\"SN{self._sn} has FW{self._fw}. -&gt; Using V265/275 data structure.\")\n            logger.info(\"Contact naneos for a firmware update to get the latest features.\")\n        elif self._fw in [295, 297, 298]:\n            self._data_structure = PARTECTOR2_DATA_STRUCTURE_V295_V297_V298\n            logger.info(f\"SN{self._sn} has FW{self._fw}. -&gt; Using V295/297/298 data structure.\")\n            logger.info(\"Contact naneos for a firmware update to get the latest features.\")\n        elif self._fw &gt;= 320:\n            self._data_structure = PARTECTOR2_DATA_STRUCTURE_V320\n            self._write_line(\"A0002!\")  # activates antispikes\n\n            if self._OUTPUT_PULSE_DIAGNOSTICS:\n                self._write_line(\"opd01!\")\n                self._data_structure.update(\n                    PARTECTOR2_OUTPUT_PULSE_DIAGNOSTIC_ADDITIONAL_DATA_STRUCTURE\n                )\n            else:\n                self._write_line(\"opd00!\")\n\n            if self._GAIN_TEST_ACTIVE:\n                waiting_time = max(10, (self._integration_time + 5))\n                self._wait_with_data_output_until = time.time() + waiting_time\n                self._write_line(\"h2001!\")  # activates harmonics output\n                self._write_line(\"e1100!\")  # strength of gain test signal\n                self._data_structure.update(PARTECTOR2_GAIN_TEST_ADDITIONAL_DATA_STRUCTURE)\n            else:\n                self._write_line(\"h2000!\")  # deactivates harmonics output\n                self._write_line(\"e0000!\")  # deactivates gain test signal\n\n            logger.info(f\"SN{self._sn} has FW{self._fw}. -&gt; Using V320 data structure.\")\n        else:\n            self._data_structure = PARTECTOR2_DATA_STRUCTURE_LEGACY\n            self._legacy_data_structure = True\n            logger.warning(f\"SN{self._sn} has FW{self._fw}. -&gt; Unofficial firmware version.\")\n            logger.warning(\"Using legacy data structure. Contact naneos for a FW update.\")\n\n    def _set_verbose_freq(self, freq: int) -&gt; None:\n        \"\"\"\n        Set the frequency of the verbose output.\n\n        :param int freq: Frequency of the verbose output in Hz. (0: off, 1: 1Hz, 2: 10Hz, 3: 100Hz)\n        \"\"\"\n\n        if freq &lt; 0 or freq &gt; 3:\n            raise ValueError(\"Frequency must be between 0 and 3!\")\n\n        self._write_line(f\"X000{freq}!\")\n</code></pre>"},{"location":"reference/naneos/partector/partector2_pro/","title":"partector2_pro","text":""},{"location":"reference/naneos/partector/partector2_pro/#naneos.partector.partector2_pro","title":"<code>naneos.partector.partector2_pro</code>","text":""},{"location":"reference/naneos/partector/partector2_pro/#naneos.partector.partector2_pro.Partector2Pro","title":"<code>Partector2Pro</code>","text":"<p>               Bases: <code>PartectorBluePrint</code></p> Source code in <code>src/naneos/partector/partector2_pro.py</code> <pre><code>class Partector2Pro(PartectorBluePrint):\n    def __init__(\n        self,\n        serial_number: Optional[int] = None,\n        port: Optional[str] = None,\n        verb_freq: int = 6,\n        hw_version: str = \"P2pro\",\n        gain_test_active: bool = True,\n        output_pulse_diagnostics: bool = True,\n    ) -&gt; None:\n        self._GAIN_TEST_ACTIVE = gain_test_active\n        self._OUTPUT_PULSE_DIAGNOSTICS = output_pulse_diagnostics\n        super().__init__(serial_number, port, verb_freq, hw_version)\n\n    def _init_serial_data_structure(self) -&gt; None:\n        \"\"\"This gets passed here and is set in the set_verbose_freq method.\"\"\"\n        self.device_type = NaneosDeviceDataPoint.DEV_TYPE_P2PRO\n\n    def _set_verbose_freq(self, freq: int) -&gt; None:\n        if freq == 0:\n            self._write_line(\"X0000!\")\n        elif freq in [1, 2, 3]:  # std p2 mode\n            if self._fw &gt;= 311:\n                self._data_structure = PARTECTOR2_DATA_STRUCTURE_V320\n\n                self._write_line(\"M0000!\")  # deactivates size dist mode\n                self._write_line(\"A0002!\")  # activates antispikes\n\n                if self._OUTPUT_PULSE_DIAGNOSTICS:\n                    self._write_line(\"opd01!\")\n                    self._data_structure.update(\n                        PARTECTOR2_OUTPUT_PULSE_DIAGNOSTIC_ADDITIONAL_DATA_STRUCTURE\n                    )\n                else:\n                    self._write_line(\"opd00!\")\n\n                if self._GAIN_TEST_ACTIVE:\n                    waiting_time = max(10, (self._integration_time + 5))\n                    self._wait_with_data_output_until = time.time() + waiting_time\n                    self._write_line(\"h2001!\")  # activates harmonics output\n                    self._write_line(\"e1100!\")  # strength of gain test signal\n                    self._data_structure.update(PARTECTOR2_GAIN_TEST_ADDITIONAL_DATA_STRUCTURE)\n                else:\n                    self._write_line(\"h2000!\")  # deactivates harmonics output\n                    self._write_line(\"e0000!\")  # deactivates gain test signal\n\n                self._write_line(f\"X000{freq}!\")  # set verbose freq\n\n            else:\n                raise RuntimeError(\"Firmware too old for P2 pro mode. Minimum FW is 311.\")\n        elif freq == 6:  # p2 pro mode\n            if self._fw &gt;= 336:\n                self._data_structure = PARTECTOR2_PRO_DATA_STRUCTURE_V336\n            else:\n                self._data_structure = PARTECTOR2_PRO_DATA_STRUCTURE_V311\n\n            self._write_line(\"X0006!\")  # activates verbose mode\n            self._write_line(\"M0004!\")  # activates size dist mode\n            self._write_line(\"A0002!\")  # activates the antispikes\n\n            if self._OUTPUT_PULSE_DIAGNOSTICS:\n                self._write_line(\"opd01!\")\n                self._data_structure.update(\n                    PARTECTOR2_OUTPUT_PULSE_DIAGNOSTIC_ADDITIONAL_DATA_STRUCTURE\n                )\n            else:\n                self._write_line(\"opd00!\")\n\n            if self._GAIN_TEST_ACTIVE:\n                waiting_time = max(10, (self._integration_time + 5))\n                self._wait_with_data_output_until = time.time() + waiting_time\n                self._write_line(\"h2001!\")  # activates harmonics output\n                self._write_line(\"e1100!\")  # strength of gain test signal\n                self._data_structure.update(PARTECTOR2_GAIN_TEST_ADDITIONAL_DATA_STRUCTURE)\n            else:\n                self._write_line(\"h2000!\")  # deactivates harmonics output\n                self._write_line(\"e0000!\")  # deactivates gain test signal\n</code></pre>"},{"location":"reference/naneos/partector/partector2_pro_cs/","title":"partector2_pro_cs","text":""},{"location":"reference/naneos/partector/partector2_pro_cs/#naneos.partector.partector2_pro_cs","title":"<code>naneos.partector.partector2_pro_cs</code>","text":""},{"location":"reference/naneos/partector/partector2_pro_cs/#naneos.partector.partector2_pro_cs.Partector2ProCs","title":"<code>Partector2ProCs</code>","text":"<p>               Bases: <code>Partector2Pro</code></p> Source code in <code>src/naneos/partector/partector2_pro_cs.py</code> <pre><code>class Partector2ProCs(Partector2Pro):\n    CS_OFF = 0\n    CS_ON = 1\n    CS_UNKNOWN = -1\n\n    def __init__(\n        self,\n        serial_number: Optional[int] = None,\n        port: Optional[str] = None,\n        verb_freq: int = 1,\n        **kwargs: Any,\n    ) -&gt; None:\n        self._catalyst_state = self.CS_UNKNOWN\n        self._auto_mode = True\n\n        self._callback_catalyst = kwargs.get(\"callback_catalyst\", None)\n        if self._callback_catalyst is None:\n            logger.error(\"No callback function for catalyst state given!\")\n            raise ValueError(\"No callback function for catalyst state given!\")\n        super().__init__(serial_number, port, verb_freq, \"P2proCS\")\n\n    def _init_serial_data_structure(self) -&gt; None:\n        self.device_type = NaneosDeviceDataPoint.DEV_TYPE_P2PRO_CS\n        self._data_structure = PARTECTOR2_PRO_CS_DATA_STRUCTURE_V315\n\n    def _set_verbose_freq(self, freq: int) -&gt; None:\n        if freq == 0:\n            self._write_line(\"X0000!\")\n        else:\n            if self._fw &gt;= 311:\n                self._data_structure = PARTECTOR2_PRO_CS_DATA_STRUCTURE_V315\n\n            self._write_line(\"h2001!\")  # activates harmonics output\n            self._write_line(\"M0004!\")  # activates size dist mode\n            self._write_line(\"X0006!\")  # activates verbose mode\n\n    def set_catalyst_state(self, state: str) -&gt; None:\n        \"\"\"Sets the catalyst state to on, off or auto.\"\"\"\n        if not self._connected:\n            return\n\n        if state == \"on\":\n            self._write_line(\"CSon!\")\n            self._cs_state = self.CS_ON\n            self._auto_mode = False\n        elif state == \"off\":\n            self._write_line(\"CSoff!\")\n            self._cs_state = self.CS_OFF\n            self._auto_mode = False\n        elif state == \"auto\":\n            self._write_line(\"CSauto!\")\n            self._auto_mode = True\n        else:\n            logger.warning(f\"Unknown catalyst state: {state} -&gt; nothing done.\")\n            return\n\n        logger.info(f\"Catalyst state set to {state}.\")\n\n    def _serial_reading_routine(self) -&gt; None:\n        line = self._read_line()\n\n        if not line or line == \"\":\n            return\n\n        if \"CS_on\" in line:\n            self._catalyst_state = self.CS_ON\n            if self._callback_catalyst:\n                self._callback_catalyst(True)\n            self._mark_cs_change()\n            return\n        elif \"CS_off\" in line:\n            self._catalyst_state = self.CS_OFF\n            if self._callback_catalyst:\n                self._callback_catalyst(False)\n            self._mark_cs_change()\n            return\n\n        self._put_line_to_queue(line)\n\n    def _mark_cs_change(self) -&gt; None:\n        try:\n            last_line = self._queue.pop()\n            last_line[-1] = f\"1{last_line[-1]}\"\n            self._queue.append(last_line)\n        except Exception as excep:\n            logger.warning(f\"Could not mark catalyst state change: {excep}\")\n\n    def _put_line_to_queue(self, line: str) -&gt; None:\n        unix_timestamp = int(datetime.now(tz=timezone.utc).timestamp())\n        data = [unix_timestamp] + line.split(\"\\t\")\n\n        self._notify_message_received()\n\n        if len(data) != len(self._data_structure):\n            self._queue_info.append(data)\n            return\n\n        state: Optional[int] = None\n        try:\n            state = int(data[-1])\n        except Exception as excep:\n            logger.warning(f\"Could not parse catalyst state in backup function: {excep}\")\n\n        if state in [0, 1] and self._catalyst_state != state:\n            if self._callback_catalyst:\n                self._callback_catalyst(state == 1)\n            self._catalyst_state = state\n            logger.warning(f\"Set catalyst state to {state} by backup function to.\")\n\n        self._queue.append(data)\n</code></pre>"},{"location":"reference/naneos/partector/partector2_pro_cs/#naneos.partector.partector2_pro_cs.Partector2ProCs.set_catalyst_state","title":"<code>set_catalyst_state(state)</code>","text":"<p>Sets the catalyst state to on, off or auto.</p> Source code in <code>src/naneos/partector/partector2_pro_cs.py</code> <pre><code>def set_catalyst_state(self, state: str) -&gt; None:\n    \"\"\"Sets the catalyst state to on, off or auto.\"\"\"\n    if not self._connected:\n        return\n\n    if state == \"on\":\n        self._write_line(\"CSon!\")\n        self._cs_state = self.CS_ON\n        self._auto_mode = False\n    elif state == \"off\":\n        self._write_line(\"CSoff!\")\n        self._cs_state = self.CS_OFF\n        self._auto_mode = False\n    elif state == \"auto\":\n        self._write_line(\"CSauto!\")\n        self._auto_mode = True\n    else:\n        logger.warning(f\"Unknown catalyst state: {state} -&gt; nothing done.\")\n        return\n\n    logger.info(f\"Catalyst state set to {state}.\")\n</code></pre>"},{"location":"reference/naneos/partector/partector_serial_manager/","title":"partector_serial_manager","text":""},{"location":"reference/naneos/partector/partector_serial_manager/#naneos.partector.partector_serial_manager","title":"<code>naneos.partector.partector_serial_manager</code>","text":""},{"location":"reference/naneos/partector/partector_serial_manager/#naneos.partector.partector_serial_manager.PartectorSerialManager","title":"<code>PartectorSerialManager</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>class PartectorSerialManager(threading.Thread):\n    def __init__(self) -&gt; None:\n        super().__init__(daemon=True)\n        self._stop_event = threading.Event()\n\n        self._data: dict[int, pd.DataFrame] = {}\n\n        self._connected_p1: dict[str, Partector1] = {}\n        self._connected_p2: dict[str, Partector2] = {}\n        self._connected_p2_pro: dict[str, Partector2Pro] = {}\n\n    def get_data(self) -&gt; dict[int, pd.DataFrame]:\n        \"\"\"Fetches the data from all connected devices and returns it.\"\"\"\n        self._fetch_data()\n        data = self._data\n        self._data = {}\n        return data\n\n    def _fetch_data(self):\n        \"\"\"Returns the data dictionary and deletes it.\"\"\"\n        for port in list(self._connected_p1.keys()):\n            points = self._connected_p1[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n        for port in list(self._connected_p2.keys()):\n            points = self._connected_p2[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n        for port in list(self._connected_p2_pro.keys()):\n            points = self._connected_p2_pro[port].get_data()\n            for point in points:\n                self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, point)\n\n    def stop(self) -&gt; None:\n        self._stop_event.set()\n\n    def run(self) -&gt; None:\n        try:\n            self._manager_loop()\n        except RuntimeError as e:\n            logger.exception(f\"SerialManager loop exited with: {e}\")\n\n    def get_connected_device_strings(self) -&gt; list[str]:\n        \"\"\"Returns a list of connected device strings.\"\"\"\n        p1_strings = [f\"SN{p._sn} (P1)\" for port, p in self._connected_p1.items()]\n        p2_strings = [f\"SN{p._sn} (P2)\" for port, p in self._connected_p2.items()]\n        p2_pro_strings = [f\"SN{p._sn} (P2 Pro)\" for port, p in self._connected_p2_pro.items()]\n\n        return p1_strings + p2_strings + p2_pro_strings\n\n    def get_gain_test_activating_devices(self) -&gt; list[int | None]:\n        \"\"\"Returns a list of serial numbers of devices with gain test active.\"\"\"\n        # _wait_with_data_output_until is larger than time.time()\n        p2_gain_test = [\n            p._sn\n            for p in self._connected_p2.values()\n            if p._wait_with_data_output_until &gt; time.time()\n        ]\n        p2_pro_gain_test = [\n            p._sn\n            for p in self._connected_p2_pro.values()\n            if p._wait_with_data_output_until &gt; time.time()\n        ]\n\n        return p2_gain_test + p2_pro_gain_test\n\n    def get_connected_addresses(self) -&gt; list[str]:\n        p1_ports = list(self._connected_p1.keys())\n        p2_ports = list(self._connected_p2.keys())\n        p2_pro_ports = list(self._connected_p2_pro.keys())\n\n        return p1_ports + p2_ports + p2_pro_ports\n\n    def get_connected_serial_numbers(self) -&gt; list[int | None]:\n        p1_serials = [p._sn for p in self._connected_p1.values()]\n        p2_serials = [p._sn for p in self._connected_p2.values()]\n        p2_pro_serials = [p._sn for p in self._connected_p2_pro.values()]\n\n        return p1_serials + p2_serials + p2_pro_serials\n\n    def _manager_loop(self) -&gt; None:\n        while not self._stop_event.is_set():\n            try:\n                possible_ports = scan_for_serial_partectors(\n                    ports_exclude=self.get_connected_addresses()\n                )\n\n                self._disconnect_unplugged_ports()\n                self._connect_to_new_ports(possible_ports)\n\n                self._fetch_data()  # Fetch data from all connected devices\n\n                time.sleep(1.0)  # Sleep to avoid busy waiting\n\n            except Exception as e:\n                logger.exception(f\"Error in serial manager loop: {e}\")\n\n        self._close_all_ports()\n\n    def _disconnect_unplugged_ports(self) -&gt; None:\n        \"\"\"Disconnects all ports that are not in the possible_ports dictionary.\"\"\"\n        # Disconnect P1 ports\n        for port in list(self._connected_p1.keys()):\n            if not self._connected_p1[port]._connected:\n                self._connected_p1[port].close()\n                self._connected_p1.pop(port, None)\n\n        # Disconnect P2 ports\n        for port in list(self._connected_p2.keys()):\n            if not self._connected_p2[port]._connected:\n                self._connected_p2[port].close()\n                self._connected_p2.pop(port, None)\n\n        # Disconnect P2 Pro ports\n        for port in list(self._connected_p2_pro.keys()):\n            if not self._connected_p2_pro[port]._connected:\n                print(f\"Disconnecting P2 Pro port: {port}\")\n                self._connected_p2_pro[port].close()\n                self._connected_p2_pro.pop(port, None)\n\n    def _connect_to_new_ports(self, possible_ports: dict[str, dict[int, str]]) -&gt; None:\n        p1_ports = possible_ports[\"P1\"].values()\n        p2_ports = possible_ports[\"P2\"].values()\n        p2pro_ports = possible_ports[\"P2pro\"].values()\n\n        for port in p1_ports:\n            self._connected_p1[port] = Partector1(port=port)\n        for port in p2_ports:\n            self._connected_p2[port] = Partector2(port=port)\n        for port in p2pro_ports:\n            self._connected_p2_pro[port] = Partector2Pro(port=port)\n\n    def _close_all_ports(self) -&gt; None:\n        for port in list(self._connected_p1.keys()):\n            self._connected_p1[port].close()\n            self._connected_p1.pop(port, None)\n\n        for port in list(self._connected_p2.keys()):\n            self._connected_p2[port].close()\n            self._connected_p2.pop(port, None)\n\n        for port in list(self._connected_p2_pro.keys()):\n            self._connected_p2_pro[port].close()\n            self._connected_p2_pro.pop(port, None)\n</code></pre>"},{"location":"reference/naneos/partector/partector_serial_manager/#naneos.partector.partector_serial_manager.PartectorSerialManager.get_connected_device_strings","title":"<code>get_connected_device_strings()</code>","text":"<p>Returns a list of connected device strings.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_connected_device_strings(self) -&gt; list[str]:\n    \"\"\"Returns a list of connected device strings.\"\"\"\n    p1_strings = [f\"SN{p._sn} (P1)\" for port, p in self._connected_p1.items()]\n    p2_strings = [f\"SN{p._sn} (P2)\" for port, p in self._connected_p2.items()]\n    p2_pro_strings = [f\"SN{p._sn} (P2 Pro)\" for port, p in self._connected_p2_pro.items()]\n\n    return p1_strings + p2_strings + p2_pro_strings\n</code></pre>"},{"location":"reference/naneos/partector/partector_serial_manager/#naneos.partector.partector_serial_manager.PartectorSerialManager.get_data","title":"<code>get_data()</code>","text":"<p>Fetches the data from all connected devices and returns it.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_data(self) -&gt; dict[int, pd.DataFrame]:\n    \"\"\"Fetches the data from all connected devices and returns it.\"\"\"\n    self._fetch_data()\n    data = self._data\n    self._data = {}\n    return data\n</code></pre>"},{"location":"reference/naneos/partector/partector_serial_manager/#naneos.partector.partector_serial_manager.PartectorSerialManager.get_gain_test_activating_devices","title":"<code>get_gain_test_activating_devices()</code>","text":"<p>Returns a list of serial numbers of devices with gain test active.</p> Source code in <code>src/naneos/partector/partector_serial_manager.py</code> <pre><code>def get_gain_test_activating_devices(self) -&gt; list[int | None]:\n    \"\"\"Returns a list of serial numbers of devices with gain test active.\"\"\"\n    # _wait_with_data_output_until is larger than time.time()\n    p2_gain_test = [\n        p._sn\n        for p in self._connected_p2.values()\n        if p._wait_with_data_output_until &gt; time.time()\n    ]\n    p2_pro_gain_test = [\n        p._sn\n        for p in self._connected_p2_pro.values()\n        if p._wait_with_data_output_until &gt; time.time()\n    ]\n\n    return p2_gain_test + p2_pro_gain_test\n</code></pre>"},{"location":"reference/naneos/partector/scanPartector/","title":"scanPartector","text":""},{"location":"reference/naneos/partector/scanPartector/#naneos.partector.scanPartector","title":"<code>naneos.partector.scanPartector</code>","text":""},{"location":"reference/naneos/partector/scanPartector/#naneos.partector.scanPartector.ScanPartector","title":"<code>ScanPartector</code>","text":"<p>               Bases: <code>PartectorBluePrint</code></p> Source code in <code>src/naneos/partector/scanPartector.py</code> <pre><code>class ScanPartector(PartectorBluePrint):\n    def __init__(\n        self,\n        serial_number: Optional[int] = None,\n        port: Optional[str] = None,\n        verb_freq: int = 1,\n    ) -&gt; None:\n        super().__init__(serial_number, port, verb_freq)\n\n    def _init_print_connection_info(self) -&gt; None:\n        pass\n\n    def _init_serial_data_structure(self) -&gt; None:\n        \"\"\"This field is not used in the scan partector, but mandatory in the partector blueprint.\"\"\"\n        pass\n\n    def _serial_wrapper(self, func: Callable[[], Any]) -&gt; Optional[Any]:\n        \"\"\"Wraps user func in try-except block. Forwards exceptions to the user.\"\"\"\n        if not self._connected:\n            return None\n\n        excep = \"Was not able to fetch the serial number!\"\n\n        for _ in range(self.SERIAL_RETRIES):\n            try:\n                return func()\n            except Exception as e:\n                # \u00dflogger.error(f\"SN{self._sn} Exception in _serial_wrapper: {e}\")\n                excep = f\"SN{self._sn} Exception occured during user function call: {e}\"\n\n        raise Exception(excep)\n\n    def _init_get_device_info(self) -&gt; None:\n        try:\n            if self._sn is None:\n                self._sn = self._get_serial_number_secure()\n            self._fw = self.get_firmware_version()\n            logger.debug(f\"Connected to SN{self._sn} on {self._port}\")\n        except Exception:\n            # this gets just passed because scan partector scans every port\n            # therefore it does not know if there is a partector\n            pass\n\n    def _set_verbose_freq(self, freq: int = 0) -&gt; None:\n        \"\"\"This field is only used to set the verbose frequency to 0\"\"\"\n        self._write_line(\"X0000!\")\n</code></pre>"},{"location":"reference/naneos/partector/scanPartector/#naneos.partector.scanPartector.scan_for_serial_partector","title":"<code>scan_for_serial_partector(serial_number, partector_version)</code>","text":"<p>Scans all possible ports using threads (fast).</p> Source code in <code>src/naneos/partector/scanPartector.py</code> <pre><code>def scan_for_serial_partector(serial_number: int, partector_version: str) -&gt; Optional[str]:\n    \"\"\"Scans all possible ports using threads (fast).\"\"\"\n    threads = []\n    q_1: Queue = Queue()\n    q_2: Queue = Queue()\n    q_2_pro: Queue = Queue()\n    q_2_pro_cs: Queue = Queue()\n\n    for port in list_serial_ports():\n        threads.append(Thread(target=__scan_port, args=(port, q_1, q_2, q_2_pro, q_2_pro_cs)))\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n\n    q: Queue = Queue()\n    if partector_version == \"P1\":\n        q = q_1\n    elif partector_version == \"P2\":\n        q = q_2\n    elif partector_version == \"P2pro\":\n        q = q_2_pro\n    elif partector_version == \"P2proCS\":\n        q = q_2_pro_cs\n\n    ports = {k: v for d in tuple(q.queue) for (k, v) in d.items()}\n    logger.debug(f\"Found ports: {ports}\")\n\n    if serial_number in ports:\n        return ports[serial_number]\n\n    return None\n</code></pre>"},{"location":"reference/naneos/partector/scanPartector/#naneos.partector.scanPartector.scan_for_serial_partectors","title":"<code>scan_for_serial_partectors(ports_exclude=None)</code>","text":"<p>Scans all possible ports using threads (fast).</p> Source code in <code>src/naneos/partector/scanPartector.py</code> <pre><code>def scan_for_serial_partectors(ports_exclude: Optional[list] = None) -&gt; dict:\n    \"\"\"Scans all possible ports using threads (fast).\"\"\"\n    threads = []\n    q_1: Queue = Queue()\n    q_2: Queue = Queue()\n    q_2_pro: Queue = Queue()\n    q_2_pro_cs: Queue = Queue()\n\n    if ports_exclude is None:\n        ports_exclude = []\n\n    for port in list_serial_ports(ports_exclude=ports_exclude):\n        threads.append(Thread(target=__scan_port, args=(port, q_1, q_2, q_2_pro, q_2_pro_cs)))\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n\n    p1 = {k: v for x in tuple(q_1.queue) for (k, v) in x.items()}\n    p2 = {k: v for x in tuple(q_2.queue) for (k, v) in x.items()}\n    p2_pro = {k: v for x in tuple(q_2_pro.queue) for (k, v) in x.items()}\n    p2_pro_cs = {k: v for x in tuple(q_2_pro_cs.queue) for (k, v) in x.items()}\n\n    return {\"P1\": p1, \"P2\": p2, \"P2pro\": p2_pro, \"P2proCS\": p2_pro_cs}\n</code></pre>"},{"location":"reference/naneos/partector_ble/","title":"partector_ble","text":""},{"location":"reference/naneos/partector_ble/#naneos.partector_ble","title":"<code>naneos.partector_ble</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/","title":"decoder","text":""},{"location":"reference/naneos/partector_ble/decoder/#naneos.partector_ble.decoder","title":"<code>naneos.partector_ble.decoder</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error/","title":"partectod_ble_decoder_aux_error","text":""},{"location":"reference/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error/#naneos.partector_ble.decoder.partectod_ble_decoder_aux_error","title":"<code>naneos.partector_ble.decoder.partectod_ble_decoder_aux_error</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error/#naneos.partector_ble.decoder.partectod_ble_decoder_aux_error.PartectorBleDecoderAuxError","title":"<code>PartectorBleDecoderAuxError</code>","text":"<p>               Bases: <code>PartectorBleDecoderBlueprint</code></p> <p>Decode the std advertisement data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error.py</code> <pre><code>class PartectorBleDecoderAuxError(PartectorBleDecoderBlueprint):\n    \"\"\"\n    Decode the std advertisement data from the Partector device.\n    \"\"\"\n\n    OFFSET_ERROR = slice(2, 6)\n    OFFSET_IDIFF_DELAY_ON = slice(6, 7)\n    OFFSET_IDIFF_DELAY_OFF = slice(7, 8)\n    OFFSET_IDIFF_AVERAGE = slice(8, 10)\n    OFFSET_IDIFF_STDV = slice(10, 12)\n    OFFSET_IDIFF_MAX = slice(12, 14)\n    OFFSET_UCOR_ONSET = slice(14, 16)\n\n    FACTOR_DIFFUSION_CURRENT = 0.01\n\n    # == External used methods =====================================================================\n    @classmethod\n    def decode(\n        cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n    ) -&gt; NaneosDeviceDataPoint:\n        \"\"\"\n        Decode the auxiliary characteristic data from the Partector device.\n        \"\"\"\n        decoded_data = NaneosDeviceDataPoint(\n            device_status=cls._get_error(data),\n            diffusion_current_delay_on=cls._get_idiff_delay_on(data),\n            diffusion_current_delay_off=cls._get_idiff_delay_off(data),\n            diffusion_current_average=cls._get_idiff_average(data),\n            diffusion_current_stddev=cls._get_idiff_stddev(data),\n            diffusion_current_max=cls._get_idiff_max(data),\n            corona_voltage_onset=cls._get_ucor_onset(data),\n        )\n\n        if not data_structure:\n            return decoded_data\n\n        # Fill the given data_structure with the decoded data\n        for field in NaneosDeviceDataPoint.BLE_AUX_ERROR_FIELD_NAMES:\n            setattr(data_structure, field, getattr(decoded_data, field))\n        return data_structure\n\n    # == Helpers ===================================================================================\n    @classmethod\n    def _get_error(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the error bits from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_ERROR], byteorder=\"little\")\n        return val\n\n    @classmethod\n    def _get_idiff_delay_on(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the diffusion current delay on from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_IDIFF_DELAY_ON], byteorder=\"little\")\n        return val\n\n    @classmethod\n    def _get_idiff_delay_off(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the diffusion current delay off from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_IDIFF_DELAY_OFF], byteorder=\"little\")\n        return val\n\n    @classmethod\n    def _get_idiff_average(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the diffusion current average from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_IDIFF_AVERAGE], byteorder=\"little\")\n        return val * cls.FACTOR_DIFFUSION_CURRENT\n\n    @classmethod\n    def _get_idiff_stddev(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the diffusion current standard deviation from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_IDIFF_STDV], byteorder=\"little\")\n        return val * cls.FACTOR_DIFFUSION_CURRENT\n\n    @classmethod\n    def _get_idiff_max(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the diffusion current maximum from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_IDIFF_MAX], byteorder=\"little\")\n        return val * cls.FACTOR_DIFFUSION_CURRENT\n\n    @classmethod\n    def _get_ucor_onset(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the corona voltage onset from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_UCOR_ONSET], byteorder=\"little\")\n        return val\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error/#naneos.partector_ble.decoder.partectod_ble_decoder_aux_error.PartectorBleDecoderAuxError.decode","title":"<code>decode(data, data_structure=None)</code>  <code>classmethod</code>","text":"<p>Decode the auxiliary characteristic data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partectod_ble_decoder_aux_error.py</code> <pre><code>@classmethod\ndef decode(\n    cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n) -&gt; NaneosDeviceDataPoint:\n    \"\"\"\n    Decode the auxiliary characteristic data from the Partector device.\n    \"\"\"\n    decoded_data = NaneosDeviceDataPoint(\n        device_status=cls._get_error(data),\n        diffusion_current_delay_on=cls._get_idiff_delay_on(data),\n        diffusion_current_delay_off=cls._get_idiff_delay_off(data),\n        diffusion_current_average=cls._get_idiff_average(data),\n        diffusion_current_stddev=cls._get_idiff_stddev(data),\n        diffusion_current_max=cls._get_idiff_max(data),\n        corona_voltage_onset=cls._get_ucor_onset(data),\n    )\n\n    if not data_structure:\n        return decoded_data\n\n    # Fill the given data_structure with the decoded data\n    for field in NaneosDeviceDataPoint.BLE_AUX_ERROR_FIELD_NAMES:\n        setattr(data_structure, field, getattr(decoded_data, field))\n    return data_structure\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_aux/","title":"partector_ble_decoder_aux","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_aux/#naneos.partector_ble.decoder.partector_ble_decoder_aux","title":"<code>naneos.partector_ble.decoder.partector_ble_decoder_aux</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_aux/#naneos.partector_ble.decoder.partector_ble_decoder_aux.PartectorBleDecoderAux","title":"<code>PartectorBleDecoderAux</code>","text":"<p>               Bases: <code>PartectorBleDecoderBlueprint</code></p> <p>Decode the std advertisement data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_aux.py</code> <pre><code>class PartectorBleDecoderAux(PartectorBleDecoderBlueprint):\n    \"\"\"\n    Decode the std advertisement data from the Partector device.\n    \"\"\"\n\n    OFFSET_CORONA_VOLTAGE = slice(0, 2)\n    OFFSET_DIFFUSION_CURRENT = slice(2, 4)\n    OFFSET_DEPOSITION_VOLTAGE = slice(4, 6)\n    OFFSET_FLOW_FROM_DP = slice(6, 8)\n    OFFSET_AMBIENT_PRESSURE = slice(8, 10)\n    OFFSET_EM_AMPLITUDE_1 = slice(10, 12)\n    OFFSET_EM_AMPLITUDE_2 = slice(12, 14)\n    OFFSET_EM_GAIN_1 = slice(14, 16)\n    OFFSET_EM_GAIN_2 = slice(16, 18)\n    OFFSET_DIFFUSION_CURRENT_OFFSET = slice(18, 20)\n\n    FACTOR_DIFFUSION_CURRENT = 0.01\n\n    # == External used methods =====================================================================\n    @classmethod\n    def decode(\n        cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n    ) -&gt; NaneosDeviceDataPoint:\n        \"\"\"\n        Decode the auxiliary characteristic data from the Partector device.\n        \"\"\"\n        decoded_data = NaneosDeviceDataPoint(\n            corona_voltage=cls._get_corona_voltage(data),\n            diffusion_current=cls._get_diffusion_current(data),\n            deposition_voltage=cls._get_deposition_voltage(data),\n            flow_from_dp=cls._get_flow_from_dp(data),\n            ambient_pressure=cls._get_ambient_pressure(data),\n            electrometer_1_amplitude=cls._get_em_amplitude_1(data),\n            electrometer_2_amplitude=cls._get_em_amplitude_2(data),\n            electrometer_1_gain=cls._get_em_gain_1(data),\n            electrometer_2_gain=cls._get_em_gain_2(data),\n            diffusion_current_offset=cls._get_diffusion_current_offset(data),\n        )\n\n        if not data_structure:\n            return decoded_data\n\n        # Fill the given data_structure with the decoded data\n        for field in NaneosDeviceDataPoint.BLE_AUX_FIELD_NAMES:\n            setattr(data_structure, field, getattr(decoded_data, field))\n        return data_structure\n\n    # == Helpers ===================================================================================\n    @classmethod\n    def _get_corona_voltage(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the corona voltage from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_CORONA_VOLTAGE], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_diffusion_current(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the diffusion current from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_DIFFUSION_CURRENT], byteorder=\"little\"))\n        return val * cls.FACTOR_DIFFUSION_CURRENT\n\n    @classmethod\n    def _get_deposition_voltage(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the deposition voltage from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_DEPOSITION_VOLTAGE], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_flow_from_dp(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the flow from DP from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_FLOW_FROM_DP], byteorder=\"little\")) / 1000.0\n        return val\n\n    @classmethod\n    def _get_ambient_pressure(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the ambient pressure from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_AMBIENT_PRESSURE], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_em_amplitude_1(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the EM amplitude 1 from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_EM_AMPLITUDE_1], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_em_amplitude_2(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the EM amplitude 2 from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_EM_AMPLITUDE_2], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_em_gain_1(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the EM gain 1 from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_EM_GAIN_1], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_em_gain_2(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the EM gain 2 from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_EM_GAIN_2], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_diffusion_current_offset(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the diffusion current offset from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_DIFFUSION_CURRENT_OFFSET], byteorder=\"little\"))\n        return val\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_aux/#naneos.partector_ble.decoder.partector_ble_decoder_aux.PartectorBleDecoderAux.decode","title":"<code>decode(data, data_structure=None)</code>  <code>classmethod</code>","text":"<p>Decode the auxiliary characteristic data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_aux.py</code> <pre><code>@classmethod\ndef decode(\n    cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n) -&gt; NaneosDeviceDataPoint:\n    \"\"\"\n    Decode the auxiliary characteristic data from the Partector device.\n    \"\"\"\n    decoded_data = NaneosDeviceDataPoint(\n        corona_voltage=cls._get_corona_voltage(data),\n        diffusion_current=cls._get_diffusion_current(data),\n        deposition_voltage=cls._get_deposition_voltage(data),\n        flow_from_dp=cls._get_flow_from_dp(data),\n        ambient_pressure=cls._get_ambient_pressure(data),\n        electrometer_1_amplitude=cls._get_em_amplitude_1(data),\n        electrometer_2_amplitude=cls._get_em_amplitude_2(data),\n        electrometer_1_gain=cls._get_em_gain_1(data),\n        electrometer_2_gain=cls._get_em_gain_2(data),\n        diffusion_current_offset=cls._get_diffusion_current_offset(data),\n    )\n\n    if not data_structure:\n        return decoded_data\n\n    # Fill the given data_structure with the decoded data\n    for field in NaneosDeviceDataPoint.BLE_AUX_FIELD_NAMES:\n        setattr(data_structure, field, getattr(decoded_data, field))\n    return data_structure\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_blueprint/","title":"partector_ble_decoder_blueprint","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_blueprint/#naneos.partector_ble.decoder.partector_ble_decoder_blueprint","title":"<code>naneos.partector_ble.decoder.partector_ble_decoder_blueprint</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_blueprint/#naneos.partector_ble.decoder.partector_ble_decoder_blueprint.PartectorBleDecoderBlueprint","title":"<code>PartectorBleDecoderBlueprint</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_blueprint.py</code> <pre><code>class PartectorBleDecoderBlueprint(ABC):\n    @classmethod\n    @abstractmethod\n    def decode(\n        cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n    ) -&gt; NaneosDeviceDataPoint:\n        \"\"\"\n        Decode the advertisement data from the Partector device. If the optional data_structure is\n        given, it will be filled with the decoded data and returned.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_blueprint/#naneos.partector_ble.decoder.partector_ble_decoder_blueprint.PartectorBleDecoderBlueprint.decode","title":"<code>decode(data, data_structure=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Decode the advertisement data from the Partector device. If the optional data_structure is given, it will be filled with the decoded data and returned.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_blueprint.py</code> <pre><code>@classmethod\n@abstractmethod\ndef decode(\n    cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n) -&gt; NaneosDeviceDataPoint:\n    \"\"\"\n    Decode the advertisement data from the Partector device. If the optional data_structure is\n    given, it will be filled with the decoded data and returned.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_size/","title":"partector_ble_decoder_size","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_size/#naneos.partector_ble.decoder.partector_ble_decoder_size","title":"<code>naneos.partector_ble.decoder.partector_ble_decoder_size</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_size/#naneos.partector_ble.decoder.partector_ble_decoder_size.PartectorBleDecoderSize","title":"<code>PartectorBleDecoderSize</code>","text":"<p>               Bases: <code>PartectorBleDecoderBlueprint</code></p> <p>Decode the std advertisement data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_size.py</code> <pre><code>class PartectorBleDecoderSize(PartectorBleDecoderBlueprint):\n    \"\"\"\n    Decode the std advertisement data from the Partector device.\n    \"\"\"\n\n    # == External used methods =====================================================================\n    @classmethod\n    def decode(\n        cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n    ) -&gt; NaneosDeviceDataPoint:\n        \"\"\"\n        Decode the auxiliary characteristic data from the Partector device.\n        \"\"\"\n        decoded_data = NaneosDeviceDataPoint(\n            particle_number_10nm=cls._get_10nm(data),\n            particle_number_16nm=cls._get_10nm(data),\n            particle_number_26nm=cls._get_26nm(data),\n            particle_number_43nm=cls._get_43nm(data),\n            particle_number_70nm=cls._get_70nm(data),\n            particle_number_114nm=cls._get_114nm(data),\n            particle_number_185nm=cls._get_185nm(data),\n            particle_number_300nm=cls._get_300nm(data),\n        )\n\n        if not data_structure:\n            return decoded_data\n\n        # Fill the given data_structure with the decoded data\n        for field in NaneosDeviceDataPoint.BLE_SIZE_DIST_FIELD_NAMES:\n            setattr(data_structure, field, getattr(decoded_data, field))\n        return data_structure\n\n    # == Helpers ===================================================================================\n    @staticmethod\n    def _get_10nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 10nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[0], data[1], data[2] &amp; 0x0F]), byteorder=\"little\")\n        )\n        return val\n\n    @staticmethod\n    def _get_16nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 16nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[2] &amp; 0xF0, data[3], data[4]]), byteorder=\"little\") &gt;&gt; 4\n        )\n        return val\n\n    @staticmethod\n    def _get_26nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 26nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[5], data[6], data[7] &amp; 0x0F]), byteorder=\"little\")\n        )\n        return val\n\n    @staticmethod\n    def _get_43nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 43nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[7] &amp; 0xF0, data[8], data[9]]), byteorder=\"little\") &gt;&gt; 4\n        )\n        return val\n\n    @staticmethod\n    def _get_70nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 70nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[10], data[11], data[12] &amp; 0x0F]), byteorder=\"little\")\n        )\n        return val\n\n    @staticmethod\n    def _get_114nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 114nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[12] &amp; 0xF0, data[13], data[14]]), byteorder=\"little\")\n            &gt;&gt; 4\n        )\n        return val\n\n    @staticmethod\n    def _get_185nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 185nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[15], data[16], data[17] &amp; 0x0F]), byteorder=\"little\")\n        )\n        return val\n\n    @staticmethod\n    def _get_300nm(data: bytes) -&gt; float:\n        \"\"\"\n        Get the 300nm value from the size characteristic data.\n        \"\"\"\n        val = float(\n            int.from_bytes(bytearray([data[17] &amp; 0xF0, data[18], data[19]]), byteorder=\"little\")\n            &gt;&gt; 4\n        )\n        return val\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_size/#naneos.partector_ble.decoder.partector_ble_decoder_size.PartectorBleDecoderSize.decode","title":"<code>decode(data, data_structure=None)</code>  <code>classmethod</code>","text":"<p>Decode the auxiliary characteristic data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_size.py</code> <pre><code>@classmethod\ndef decode(\n    cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n) -&gt; NaneosDeviceDataPoint:\n    \"\"\"\n    Decode the auxiliary characteristic data from the Partector device.\n    \"\"\"\n    decoded_data = NaneosDeviceDataPoint(\n        particle_number_10nm=cls._get_10nm(data),\n        particle_number_16nm=cls._get_10nm(data),\n        particle_number_26nm=cls._get_26nm(data),\n        particle_number_43nm=cls._get_43nm(data),\n        particle_number_70nm=cls._get_70nm(data),\n        particle_number_114nm=cls._get_114nm(data),\n        particle_number_185nm=cls._get_185nm(data),\n        particle_number_300nm=cls._get_300nm(data),\n    )\n\n    if not data_structure:\n        return decoded_data\n\n    # Fill the given data_structure with the decoded data\n    for field in NaneosDeviceDataPoint.BLE_SIZE_DIST_FIELD_NAMES:\n        setattr(data_structure, field, getattr(decoded_data, field))\n    return data_structure\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_std/","title":"partector_ble_decoder_std","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_std/#naneos.partector_ble.decoder.partector_ble_decoder_std","title":"<code>naneos.partector_ble.decoder.partector_ble_decoder_std</code>","text":""},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_std/#naneos.partector_ble.decoder.partector_ble_decoder_std.PartectorBleDecoderStd","title":"<code>PartectorBleDecoderStd</code>","text":"<p>               Bases: <code>PartectorBleDecoderBlueprint</code></p> <p>Decode the std advertisement data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_std.py</code> <pre><code>class PartectorBleDecoderStd(PartectorBleDecoderBlueprint):\n    \"\"\"\n    Decode the std advertisement data from the Partector device.\n    \"\"\"\n\n    OFFSET_SERIAL_NUMBER = slice(14, 16)\n\n    OFFSET_DEVICE_STATE_1 = slice(10, 12)\n    ELEMET_DEVICE_STATE_2 = 19\n\n    OFFSET_LDSA = slice(0, 3)\n    OFFSET_AVERAGE_PARTICLE_DIAMETER = slice(3, 5)\n    OFFSET_PARTICLE_NUMBER = slice(5, 8)\n    OFFSET_TEMPERATURE = slice(8, 9)\n    OFFSET_RELATIVE_HUMIDITY = slice(9, 10)\n    OFFSET_BATTERY_VOLTAGE = slice(12, 14)\n    OFFSET_PARTICLE_MASS = slice(16, 19)\n\n    FACTOR_LDSA = 0.01\n    FACTOR_BATTERY_VOLTAGE = 0.01\n    FACTOR_PARTICLE_MASS = 0.01\n\n    # == External used methods =====================================================================\n    @classmethod\n    def get_serial_number(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the serial number from the advertisement data.\n        \"\"\"\n        return int.from_bytes(data[cls.OFFSET_SERIAL_NUMBER], byteorder=\"little\")\n\n    @classmethod\n    def decode(\n        cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n    ) -&gt; NaneosDeviceDataPoint:\n        \"\"\"\n        Decode the advertisement data from the Partector device.\n        \"\"\"\n        decoded_data = NaneosDeviceDataPoint(\n            serial_number=cls.get_serial_number(data),\n            ldsa=cls._get_ldsa(data),\n            average_particle_diameter=cls._get_diameter(data),\n            particle_number_concentration=cls._get_particle_number(data),\n            temperature=cls._get_temperature(data),\n            relative_humidity=cls._get_relative_humidity(data),\n            device_status=cls._get_device_state(data),\n            battery_voltage=cls._get_battery_voltage(data),\n            particle_mass=cls._get_particle_mass(data),\n        )\n\n        if not data_structure:\n            return decoded_data\n\n        # Fill the given data_structure with the decoded data\n        for field in NaneosDeviceDataPoint.BLE_STD_FIELD_NAMES:\n            setattr(data_structure, field, getattr(decoded_data, field))\n        return data_structure\n\n    # == Helpers ===================================================================================\n    @classmethod\n    def _get_ldsa(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the LDSA from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_LDSA], byteorder=\"little\"))\n        return val * cls.FACTOR_LDSA\n\n    @classmethod\n    def _get_diameter(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the particle diameter from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_AVERAGE_PARTICLE_DIAMETER], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_particle_number(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the particle number from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_PARTICLE_NUMBER], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_temperature(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the temperature from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_TEMPERATURE], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_relative_humidity(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the relative humidity from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_RELATIVE_HUMIDITY], byteorder=\"little\"))\n        return val\n\n    @classmethod\n    def _get_device_state(cls, data: bytes) -&gt; int:\n        \"\"\"\n        Get the device state from the advertisement data.\n        \"\"\"\n        val = int.from_bytes(data[cls.OFFSET_DEVICE_STATE_1], byteorder=\"little\")\n        val += ((int(data[cls.ELEMET_DEVICE_STATE_2]) &gt;&gt; 1) &amp; 0b01111111) &lt;&lt; 16\n        return val\n\n    @classmethod\n    def _get_battery_voltage(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the battery voltage from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_BATTERY_VOLTAGE], byteorder=\"little\"))\n        return val * cls.FACTOR_BATTERY_VOLTAGE\n\n    @classmethod\n    def _get_particle_mass(cls, data: bytes) -&gt; float:\n        \"\"\"\n        Get the particle mass from the advertisement data.\n        \"\"\"\n        val = float(int.from_bytes(data[cls.OFFSET_PARTICLE_MASS], byteorder=\"little\"))\n        return val * cls.FACTOR_PARTICLE_MASS\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_std/#naneos.partector_ble.decoder.partector_ble_decoder_std.PartectorBleDecoderStd.decode","title":"<code>decode(data, data_structure=None)</code>  <code>classmethod</code>","text":"<p>Decode the advertisement data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_std.py</code> <pre><code>@classmethod\ndef decode(\n    cls, data: bytes, data_structure: Optional[NaneosDeviceDataPoint] = None\n) -&gt; NaneosDeviceDataPoint:\n    \"\"\"\n    Decode the advertisement data from the Partector device.\n    \"\"\"\n    decoded_data = NaneosDeviceDataPoint(\n        serial_number=cls.get_serial_number(data),\n        ldsa=cls._get_ldsa(data),\n        average_particle_diameter=cls._get_diameter(data),\n        particle_number_concentration=cls._get_particle_number(data),\n        temperature=cls._get_temperature(data),\n        relative_humidity=cls._get_relative_humidity(data),\n        device_status=cls._get_device_state(data),\n        battery_voltage=cls._get_battery_voltage(data),\n        particle_mass=cls._get_particle_mass(data),\n    )\n\n    if not data_structure:\n        return decoded_data\n\n    # Fill the given data_structure with the decoded data\n    for field in NaneosDeviceDataPoint.BLE_STD_FIELD_NAMES:\n        setattr(data_structure, field, getattr(decoded_data, field))\n    return data_structure\n</code></pre>"},{"location":"reference/naneos/partector_ble/decoder/partector_ble_decoder_std/#naneos.partector_ble.decoder.partector_ble_decoder_std.PartectorBleDecoderStd.get_serial_number","title":"<code>get_serial_number(data)</code>  <code>classmethod</code>","text":"<p>Get the serial number from the advertisement data.</p> Source code in <code>src/naneos/partector_ble/decoder/partector_ble_decoder_std.py</code> <pre><code>@classmethod\ndef get_serial_number(cls, data: bytes) -&gt; int:\n    \"\"\"\n    Get the serial number from the advertisement data.\n    \"\"\"\n    return int.from_bytes(data[cls.OFFSET_SERIAL_NUMBER], byteorder=\"little\")\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_connection/","title":"partector_ble_connection","text":""},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection","title":"<code>naneos.partector_ble.partector_ble_connection</code>","text":""},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection.PartectorBleConnection","title":"<code>PartectorBleConnection</code>","text":"Source code in <code>src/naneos/partector_ble/partector_ble_connection.py</code> <pre><code>class PartectorBleConnection:\n    SERVICE_UUID = \"0bd51666-e7cb-469b-8e4d-2742f1ba77cc\"\n    CHAR_UUIDS = {\n        \"std\": \"e7add780-b042-4876-aae1-112855353cc1\",\n        \"aux\": \"e7add781-b042-4876-aae1-112855353cc1\",\n        \"write\": \"e7add782-b042-4876-aae1-112855353cc1\",\n        \"read\": \"e7add783-b042-4876-aae1-112855353cc1\",\n        \"size_dist\": \"e7add784-b042-4876-aae1-112855353cc1\",\n    }\n\n    # static methods ###############################################################################\n    @staticmethod\n    def create_connection_queue() -&gt; asyncio.Queue[NaneosDeviceDataPoint]:\n        \"\"\"Create a queue for the connection data.\"\"\"\n        # Increased maxsize to 500 to handle bursts from multiple devices\n        # Prevents message loss on Raspberry Pi with many concurrent connections\n        queue_connection: asyncio.Queue[NaneosDeviceDataPoint] = asyncio.Queue(maxsize=500)\n\n        return queue_connection\n\n    # == Lifecycle and Context Management ==========================================================\n    def __init__(\n        self,\n        device: BLEDevice,\n        loop: asyncio.AbstractEventLoop,\n        serial_number: int,\n        queue: asyncio.Queue[NaneosDeviceDataPoint],\n    ) -&gt; None:\n        \"\"\"\n        Initializes the BLE connection with the given device, event loop, and queue.\n\n        Args:\n            device (BLEDevice): The BLE device to connect to.\n            loop (asyncio.AbstractEventLoop): The event loop to run the connection in.\n            serial_number (int): The serial number of the device.\n        \"\"\"\n        self.SERIAL_NUMBER = serial_number\n        self._device_type = NaneosDeviceDataPoint.DEV_TYPE_P2  # Thats the deafault value\n        self._data = NaneosDeviceDataPoint()\n        self._next_ts = 0.0\n        self._last_aux_data_ts = time.time()\n        self._queue = queue\n\n        # Decode queue to decouple decoding from BLE callbacks\n        # This prevents blocking the event loop when decoding heavy data\n        self._decode_queue: asyncio.Queue = asyncio.Queue(maxsize=200)\n\n        self._device = device\n        self._loop = loop\n        self._task: asyncio.Task | None = None\n        self._stop_event = asyncio.Event()\n        self._stop_event.set()  # stopped by default\n        self._client = BleakClient(device, self._disconnect_callback, timeout=10)\n\n    async def __aenter__(self) -&gt; PartectorBleConnection:\n        self.start()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        await self.stop()\n\n    # == Public Methods ============================================================================\n    def start(self) -&gt; None:\n        \"\"\"Starts the scanner.\"\"\"\n        if not self._stop_event.is_set():\n            logger.warning(\"SN{self._serial_number}: start() called while already running\")\n            return\n        self._stop_event.clear()\n        self._task = self._loop.create_task(self._run())\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stops the scanner.\"\"\"\n        self._stop_event.set()\n        if self._task and not self._task.done():\n            await self._task\n        logger.info(f\"SN{self.SERIAL_NUMBER}: PartectorBleConnection stopped\")\n\n    async def _run(self) -&gt; None:\n        waiting_seconds = 0\n\n        try:\n            self._next_ts = int(time.time()) + 1.0\n\n            # Create decode task to run in parallel\n            # This prevents decoding from blocking the event loop\n            self._loop.create_task(self._decode_routine())\n\n            while not self._stop_event.is_set():\n                try:\n                    if self._last_aux_data_ts + 60 &lt; time.time():\n                        logger.info(\n                            f\"SN{self.SERIAL_NUMBER}: No aux data received for 60 seconds, disconnecting to reset.\"\n                        )\n                        await self._disconnect_gracefully()\n                        self._last_aux_data_ts = time.time()\n                        waiting_seconds = 5  # wait 5 seconds before reconnecting\n\n                    waiting_seconds = max(0, waiting_seconds - 1)\n                    wait = self._next_ts - time.time()\n                    if wait &gt; 0:\n                        await asyncio.sleep(wait)\n                        self._next_ts += 1.0\n                    else:\n                        if self._client.is_connected:\n                            logger.info(f\"SN{self.SERIAL_NUMBER}: Waiting time negative: {wait}\")\n                        self._next_ts = int(time.time()) + 1.0\n\n                    if self._client.is_connected:\n                        if (\n                            self._device_type == NaneosDeviceDataPoint.DEV_TYPE_P2PRO\n                            and self._data.particle_number_10nm is None\n                            and self._data.particle_number_16nm is None\n                            and self._data.particle_number_26nm is None\n                            and self._data.particle_number_43nm is None\n                            and self._data.particle_number_70nm is None\n                            and self._data.particle_number_114nm is None\n                            and self._data.particle_number_185nm is None\n                            and self._data.particle_number_300nm is None\n                        ):\n                            self._data.particle_number_concentration = None\n                            self._data.average_particle_diameter = None\n\n                        self._queue.put_nowait(self._data)\n                        self._data = NaneosDeviceDataPoint(\n                            device_type=self._device_type,\n                            serial_number=self.SERIAL_NUMBER,\n                            connection_type=NaneosDeviceDataPoint.CONN_TYPE_CONNECTED,\n                            # TODO: add firware version from device here\n                        )\n                        continue\n\n                    if waiting_seconds == 0:\n                        await self._client.connect(timeout=5)  # 5 seconds for windows...\n                        if self._client.is_connected:\n                            await self._client.start_notify(\n                                self.CHAR_UUIDS[\"std\"], self._callback_std\n                            )\n                            await self._client.start_notify(\n                                self.CHAR_UUIDS[\"aux\"], self._callback_aux\n                            )\n                            await self._client.start_notify(\n                                self.CHAR_UUIDS[\"size_dist\"], self._callback_size_dist\n                            )\n                        logger.info(f\"SN{self.SERIAL_NUMBER}: Connected to {self._device.address}\")\n\n                    self._next_ts = int(time.time()) + 1.0\n                except asyncio.TimeoutError:\n                    logger.info(f\"SN{self.SERIAL_NUMBER}: Connection timeout.\")\n                    waiting_seconds = 30\n                    await asyncio.sleep(0.5)\n                except BleakDeviceNotFoundError:\n                    logger.info(f\"SN{self.SERIAL_NUMBER}: Device not found or probably old BLE.\")\n                    waiting_seconds = 30\n                    await asyncio.sleep(0.5)\n                except Exception as e:\n                    # if exception contains \"not found\" increase waiting time to 30 seconds and do not spam\n                    if \"not found\" in str(e).lower():\n                        logger.info(\n                            f\"SN{self.SERIAL_NUMBER}: Device not found or probably old BLE: {e}\"\n                        )\n                        waiting_seconds = 30\n                    else:\n                        logger.warning(f\"SN{self.SERIAL_NUMBER}: Unknown exception: {e}\")\n\n                    await asyncio.sleep(0.5)\n        except asyncio.CancelledError:\n            logger.warning(f\"SN{self.SERIAL_NUMBER}: _run task cancelled.\")\n        except Exception as e:\n            logger.exception(f\"SN{self.SERIAL_NUMBER}: _run task failed: {e}\")\n        finally:\n            await self._disconnect_gracefully()\n\n    async def _decode_routine(self) -&gt; None:\n        \"\"\"Asynchronously decodes BLE data from the decode queue.\n\n        This runs in parallel with the main connection loop, preventing\n        decoding from blocking the event loop when handling multiple connections.\n        \"\"\"\n        while not self._stop_event.is_set():\n            try:\n                # Non-blocking check with timeout to allow graceful shutdown\n                try:\n                    char_type, data = await asyncio.wait_for(self._decode_queue.get(), timeout=0.5)\n                except asyncio.TimeoutError:\n                    continue\n\n                # Update timestamp for all decodings\n                self._data.unix_timestamp = int(time.time() * 1000)\n\n                # Decode based on characteristic type\n                if char_type == \"std\":\n                    self._data = PartectorBleDecoderStd.decode(data, data_structure=self._data)\n                    logger.debug(f\"SN{self.SERIAL_NUMBER}: Decoded std: {data.hex()}\")\n\n                elif char_type == \"aux\":\n                    # Check for aux error data\n                    if len(data) &gt;= 2 and data[0] == 255 and data[1] == 255:\n                        self._data = PartectorBleDecoderAuxError.decode(\n                            data, data_structure=self._data\n                        )\n                    else:\n                        self._data = PartectorBleDecoderAux.decode(data, data_structure=self._data)\n                    logger.debug(f\"SN{self.SERIAL_NUMBER}: Decoded aux: {data.hex()}\")\n\n                elif char_type == \"size_dist\":\n                    self._device_type = NaneosDeviceDataPoint.DEV_TYPE_P2PRO\n                    self._data = PartectorBleDecoderSize.decode(data, data_structure=self._data)\n                    logger.debug(f\"SN{self.SERIAL_NUMBER}: Decoded size_dist: {data.hex()}\")\n\n            except Exception as e:\n                logger.warning(f\"SN{self.SERIAL_NUMBER}: Error in decode routine: {e}\")\n\n    async def _disconnect_gracefully(self) -&gt; None:\n        if not self._client.is_connected:\n            return\n\n        try:\n            await asyncio.wait_for(self._client.stop_notify(self.CHAR_UUIDS[\"std\"]), timeout=1)\n            await asyncio.sleep(0.5)  # wait for windows to free resources\n            await asyncio.wait_for(self._client.stop_notify(self.CHAR_UUIDS[\"aux\"]), timeout=1)\n            await asyncio.sleep(0.5)  # wait for windows to free resources\n            await asyncio.wait_for(\n                self._client.stop_notify(self.CHAR_UUIDS[\"size_dist\"]), timeout=1\n            )\n            await asyncio.sleep(0.5)  # wait for windows to free resources\n        except Exception as e:\n            logger.debug(f\"SN{self.SERIAL_NUMBER}: Failed to stop notify: {e}\")\n\n        try:\n            await asyncio.wait_for(self._client.disconnect(), timeout=1)\n            await asyncio.sleep(0.5)  # wait for windows to free resources\n        except Exception as e:\n            logger.debug(f\"SN{self.SERIAL_NUMBER}: Failed to disconnect: {e}\")\n\n    def _disconnect_callback(self, client: BleakClient) -&gt; None:\n        \"\"\"Callback on disconnect.\"\"\"\n        logger.debug(f\"SN{self.SERIAL_NUMBER}: Disconnect callback called\")\n\n    def _callback_std(self, characteristic: BleakGATTCharacteristic, data: bytearray) -&gt; None:\n        \"\"\"Callback on data received (std characteristic).\n\n        Non-blocking: puts data in decode queue instead of decoding directly.\n        Actual decoding happens asynchronously in _decode_routine().\n        \"\"\"\n        try:\n            self._decode_queue.put_nowait((\"std\", bytes(data)))\n        except asyncio.QueueFull:\n            logger.warning(f\"SN{self.SERIAL_NUMBER}: Decode queue full, dropping std data\")\n\n    def _callback_aux(self, characteristic: BleakGATTCharacteristic, data: bytearray) -&gt; None:\n        \"\"\"Callback on data received (aux characteristic).\n\n        Non-blocking: puts data in decode queue instead of decoding directly.\n        Actual decoding happens asynchronously in _decode_routine().\n        \"\"\"\n        self._last_aux_data_ts = time.time()\n        try:\n            self._decode_queue.put_nowait((\"aux\", bytes(data)))\n        except asyncio.QueueFull:\n            logger.warning(f\"SN{self.SERIAL_NUMBER}: Decode queue full, dropping aux data\")\n\n    def _callback_size_dist(self, characteristic: BleakGATTCharacteristic, data: bytearray) -&gt; None:\n        \"\"\"Callback on data received (size_dist characteristic).\n\n        Non-blocking: puts data in decode queue instead of decoding directly.\n        Actual decoding happens asynchronously in _decode_routine().\n        \"\"\"\n        try:\n            self._decode_queue.put_nowait((\"size_dist\", bytes(data)))\n        except asyncio.QueueFull:\n            logger.warning(f\"SN{self.SERIAL_NUMBER}: Decode queue full, dropping size_dist data\")\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection.PartectorBleConnection.__init__","title":"<code>__init__(device, loop, serial_number, queue)</code>","text":"<p>Initializes the BLE connection with the given device, event loop, and queue.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>BLEDevice</code> <p>The BLE device to connect to.</p> required <code>loop</code> <code>AbstractEventLoop</code> <p>The event loop to run the connection in.</p> required <code>serial_number</code> <code>int</code> <p>The serial number of the device.</p> required Source code in <code>src/naneos/partector_ble/partector_ble_connection.py</code> <pre><code>def __init__(\n    self,\n    device: BLEDevice,\n    loop: asyncio.AbstractEventLoop,\n    serial_number: int,\n    queue: asyncio.Queue[NaneosDeviceDataPoint],\n) -&gt; None:\n    \"\"\"\n    Initializes the BLE connection with the given device, event loop, and queue.\n\n    Args:\n        device (BLEDevice): The BLE device to connect to.\n        loop (asyncio.AbstractEventLoop): The event loop to run the connection in.\n        serial_number (int): The serial number of the device.\n    \"\"\"\n    self.SERIAL_NUMBER = serial_number\n    self._device_type = NaneosDeviceDataPoint.DEV_TYPE_P2  # Thats the deafault value\n    self._data = NaneosDeviceDataPoint()\n    self._next_ts = 0.0\n    self._last_aux_data_ts = time.time()\n    self._queue = queue\n\n    # Decode queue to decouple decoding from BLE callbacks\n    # This prevents blocking the event loop when decoding heavy data\n    self._decode_queue: asyncio.Queue = asyncio.Queue(maxsize=200)\n\n    self._device = device\n    self._loop = loop\n    self._task: asyncio.Task | None = None\n    self._stop_event = asyncio.Event()\n    self._stop_event.set()  # stopped by default\n    self._client = BleakClient(device, self._disconnect_callback, timeout=10)\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection.PartectorBleConnection.create_connection_queue","title":"<code>create_connection_queue()</code>  <code>staticmethod</code>","text":"<p>Create a queue for the connection data.</p> Source code in <code>src/naneos/partector_ble/partector_ble_connection.py</code> <pre><code>@staticmethod\ndef create_connection_queue() -&gt; asyncio.Queue[NaneosDeviceDataPoint]:\n    \"\"\"Create a queue for the connection data.\"\"\"\n    # Increased maxsize to 500 to handle bursts from multiple devices\n    # Prevents message loss on Raspberry Pi with many concurrent connections\n    queue_connection: asyncio.Queue[NaneosDeviceDataPoint] = asyncio.Queue(maxsize=500)\n\n    return queue_connection\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection.PartectorBleConnection.start","title":"<code>start()</code>","text":"<p>Starts the scanner.</p> Source code in <code>src/naneos/partector_ble/partector_ble_connection.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the scanner.\"\"\"\n    if not self._stop_event.is_set():\n        logger.warning(\"SN{self._serial_number}: start() called while already running\")\n        return\n    self._stop_event.clear()\n    self._task = self._loop.create_task(self._run())\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_connection/#naneos.partector_ble.partector_ble_connection.PartectorBleConnection.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stops the scanner.</p> Source code in <code>src/naneos/partector_ble/partector_ble_connection.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stops the scanner.\"\"\"\n    self._stop_event.set()\n    if self._task and not self._task.done():\n        await self._task\n    logger.info(f\"SN{self.SERIAL_NUMBER}: PartectorBleConnection stopped\")\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_decoder/","title":"partector_ble_decoder","text":""},{"location":"reference/naneos/partector_ble/partector_ble_decoder/#naneos.partector_ble.partector_ble_decoder","title":"<code>naneos.partector_ble.partector_ble_decoder</code>","text":""},{"location":"reference/naneos/partector_ble/partector_ble_decoder/#naneos.partector_ble.partector_ble_decoder.PartectorBleDecoder","title":"<code>PartectorBleDecoder</code>","text":"<p>Decode the BLE data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/partector_ble_decoder.py</code> <pre><code>class PartectorBleDecoder:\n    \"\"\"\n    Decode the BLE data from the Partector device.\n    \"\"\"\n\n    VALID_DATA_LENGTHS = {22, 44}\n\n    EXPECTED_PROTOCOL_BYTE_1 = \"X\".encode(\"utf-8\")[0]\n    EXPECTED_PROTOCOL_BYTE_1_POSITION = 0\n    EXPECTED_PROTOCOL_BYTE_2 = \"F\".encode(\"utf-8\")[0]\n    EXPECTED_PROTOCOL_BYTE_2_POSITION = 21\n\n    EXPECTED_PROTOCOL_BYTE_3 = \"Y\".encode(\"utf-8\")[0]\n    EXPECTED_PROTOCOL_BYTE_3_POSITION = 22\n    EXPECTED_PROTOCOL_BYTE_4 = \"F\".encode(\"utf-8\")[0]\n    EXPECTED_PROTOCOL_BYTE_4_POSITION = 43\n\n    SLICE_ADVERTISEMENT = slice(1, 21)\n    SLICE_SCAN_RESPONSE = slice(23, 43)\n\n    # == Public Methods ============================================================================\n    @classmethod\n    def decode_partector_advertisement(\n        cls, adv: AdvertisementData\n    ) -&gt; Optional[tuple[bytes, Optional[bytes]]]:\n        \"\"\"\n        Decode the standard characteristic data from the Partector device.\n        \"\"\"\n\n        adv_bytes = PartectorBleDecoder._get_adv_bytes(adv)\n        if not cls._check_data_format(adv_bytes):\n            return None\n\n        return cls._remove_protocol_bytes(adv_bytes)\n\n    @staticmethod\n    def _get_adv_bytes(adv: AdvertisementData) -&gt; bytes:\n        \"\"\"\n        Returns the full advertisement data from the Partector device.\n        We are violating the BLE standard here by using the manufacturer data field for our own purposes.\n        This is not a good practice, but it was the only way to put more data into the advertisement.\n        \"\"\"\n        manufacturer_data = adv.manufacturer_data\n        manufacturer_id_bytes = next(iter(manufacturer_data.keys())).to_bytes(2, \"little\")\n        manufacturer_payload = next(iter(manufacturer_data.values()))\n        adv_bytes = manufacturer_id_bytes + manufacturer_payload\n\n        return adv_bytes\n\n    @classmethod\n    def _check_data_format(cls, data: bytes) -&gt; bool:\n        \"\"\"\n        Check if the data format is valid.\n        \"\"\"\n\n        if len(data) not in cls.VALID_DATA_LENGTHS:\n            return False\n\n        if (\n            data[cls.EXPECTED_PROTOCOL_BYTE_1_POSITION] != cls.EXPECTED_PROTOCOL_BYTE_1\n            or data[cls.EXPECTED_PROTOCOL_BYTE_2_POSITION] != cls.EXPECTED_PROTOCOL_BYTE_2\n        ):\n            return False\n\n        if len(data) &gt; 22:\n            if (\n                data[cls.EXPECTED_PROTOCOL_BYTE_3_POSITION] != cls.EXPECTED_PROTOCOL_BYTE_3\n                or data[cls.EXPECTED_PROTOCOL_BYTE_4_POSITION] != cls.EXPECTED_PROTOCOL_BYTE_4\n            ):\n                return False\n\n        return True\n\n    @classmethod\n    def _remove_protocol_bytes(cls, data: bytes) -&gt; tuple[bytes, Optional[bytes]]:\n        \"\"\"\n        Remove the protocol bytes from the data and returns the advertisement data and the scan\n        response data in a tuple. The scan response data is optional and may be None if not present.\n        \"\"\"\n        adv = data[cls.SLICE_ADVERTISEMENT]\n        scan_response = None\n\n        if len(data) &gt; 22:\n            scan_response = data[cls.SLICE_SCAN_RESPONSE]\n\n        return (adv, scan_response)\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_decoder/#naneos.partector_ble.partector_ble_decoder.PartectorBleDecoder.decode_partector_advertisement","title":"<code>decode_partector_advertisement(adv)</code>  <code>classmethod</code>","text":"<p>Decode the standard characteristic data from the Partector device.</p> Source code in <code>src/naneos/partector_ble/partector_ble_decoder.py</code> <pre><code>@classmethod\ndef decode_partector_advertisement(\n    cls, adv: AdvertisementData\n) -&gt; Optional[tuple[bytes, Optional[bytes]]]:\n    \"\"\"\n    Decode the standard characteristic data from the Partector device.\n    \"\"\"\n\n    adv_bytes = PartectorBleDecoder._get_adv_bytes(adv)\n    if not cls._check_data_format(adv_bytes):\n        return None\n\n    return cls._remove_protocol_bytes(adv_bytes)\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_manager/","title":"partector_ble_manager","text":""},{"location":"reference/naneos/partector_ble/partector_ble_manager/#naneos.partector_ble.partector_ble_manager","title":"<code>naneos.partector_ble.partector_ble_manager</code>","text":""},{"location":"reference/naneos/partector_ble/partector_ble_manager/#naneos.partector_ble.partector_ble_manager.PartectorBleManager","title":"<code>PartectorBleManager</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src/naneos/partector_ble/partector_ble_manager.py</code> <pre><code>class PartectorBleManager(threading.Thread):\n    def __init__(self) -&gt; None:\n        super().__init__(daemon=True)\n        self._stop_event = threading.Event()\n        self._task_stop_event = asyncio.Event()\n\n        self._queue_scanner = PartectorBleScanner.create_scanner_queue()\n        self._queue_connection = PartectorBleConnection.create_connection_queue()\n        self._connections: dict[int, tuple[asyncio.Task, int]] = {}  # key: serial_number\n\n        self._data: dict[int, pd.DataFrame] = {}\n\n    def get_data(self) -&gt; dict[int, pd.DataFrame]:\n        \"\"\"Returns the data dictionary and deletes it.\"\"\"\n        data = self._data\n        self._data = {}\n        return data\n\n    def stop(self) -&gt; None:\n        self._task_stop_event.set()\n        self._stop_event.set()\n\n    def run(self) -&gt; None:\n        try:\n            asyncio.run(self._async_run())\n        except RuntimeError as e:\n            logger.exception(f\"BLEManager loop exited with: {e}\")\n\n    def get_connected_device_strings(self) -&gt; list[str]:\n        \"\"\"Returns a list of connected device strings.\"\"\"\n        # first make a copy to avoid runtime dict change issues\n        connections_copy = self._connections.copy()\n        sns = connections_copy.keys()\n        device_types = [connections_copy[s][1] for s in sns]\n\n        sns_list = []\n        for sn, dev_type in zip(sns, device_types):\n            if dev_type == NaneosDeviceDataPoint.DEV_TYPE_P2PRO:\n                sns_list.append(f\"SN{sn} (P2 Pro)\")\n        for sn, dev_type in zip(sns, device_types):\n            if dev_type == NaneosDeviceDataPoint.DEV_TYPE_P2:\n                sns_list.append(f\"SN{sn} (P2)\")\n\n        return sns_list\n\n    def get_connected_serial_numbers(self) -&gt; list[int | None]:\n        \"\"\"Returns a list of connected serial numbers.\"\"\"\n        return list(self._connections.keys())\n\n    async def _bleak_is_bluetooth_adapter_available(self) -&gt; bool:\n        \"\"\"Check if the Bluetooth adapter is available and powered on.\"\"\"\n        try:\n            # Try to get adapter info - this will fail if adapter is not available\n            scanner = BleakScanner()\n            # Test if we can discover devices briefly\n            await scanner.start()\n            await scanner.stop()\n            return True\n        except Exception as e:\n            logger.debug(f\"Bluetooth adapter not available: {e}\")\n            return False\n\n    async def _linux_is_bluetooth_adapter_available(self) -&gt; bool:\n        \"\"\"\n        Nutzt BlueZ (bluetoothctl show), um zu pr\u00fcfen, ob\n        - ein Bluetooth-Controller existiert und\n        - er eingeschaltet (\"Powered: yes\") ist.\n        \"\"\"\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                \"bluetoothctl\",\n                \"show\",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n            stdout, stderr = await proc.communicate()\n\n            if proc.returncode != 0:\n                logger.debug(\n                    \"bluetoothctl show failed with code %s: %s\",\n                    proc.returncode,\n                    stderr.decode(errors=\"ignore\").strip(),\n                )\n                return False\n\n            output = stdout.decode(errors=\"ignore\")\n\n            if \"No default controller available\" in output:\n                logger.debug(\"No default Bluetooth controller available (BlueZ).\")\n                return False\n\n            powered = None\n            for line in output.splitlines():\n                line = line.strip()\n                if line.lower().startswith(\"powered:\"):\n                    powered = \"yes\" in line.lower()\n                    break\n\n            if powered is not None:\n                return powered\n\n            logger.debug(\"Bluetooth controller found but no 'Powered' field in output.\")\n            return False\n\n        except FileNotFoundError:\n            logger.debug(\"bluetoothctl not found on system.\")\n            return False\n\n        except Exception as e:\n            logger.debug(f\"Error while checking Bluetooth adapter via bluetoothctl: {e}\")\n            return False\n\n    async def _is_bluetooth_adapter_available(self) -&gt; bool:\n        if sys.platform.startswith(\"linux\"):\n            return await self._linux_is_bluetooth_adapter_available()\n        else:\n            return await self._bleak_is_bluetooth_adapter_available()\n\n    async def _wait_for_bluetooth_adapter(self) -&gt; None:\n        \"\"\"Wait for the Bluetooth adapter to become available.\"\"\"\n        adapter_check_interval = 3.0  # seconds\n\n        while not self._stop_event.is_set():\n            if await self._is_bluetooth_adapter_available():\n                logger.info(\"Bluetooth adapter is available and ready.\")\n                return\n\n            logger.info(\n                f\"Bluetooth adapter not available. Retrying in {adapter_check_interval} seconds...\"\n            )\n            await asyncio.sleep(adapter_check_interval)\n\n    async def _async_run(self):\n        self._loop = asyncio.get_event_loop()\n        while not self._stop_event.is_set():\n            try:\n                # Wait for Bluetooth adapter to become available\n                await self._wait_for_bluetooth_adapter()\n                self._task_stop_event.clear()\n\n                async with PartectorBleScanner(loop=self._loop, queue=self._queue_scanner):\n                    logger.info(\"Scanner started.\")\n                    await self._manager_loop()\n                await self._kill_all_connections()  # just to be safe\n            except asyncio.CancelledError:\n                logger.info(\"BLEManager cancelled.\")\n            finally:\n                logger.info(\"BLEManager cleanup complete.\")\n\n    async def _manager_loop(self) -&gt; None:\n        while not self._stop_event.is_set():\n            try:\n                if not await self._is_bluetooth_adapter_available():\n                    logger.warning(\"Bluetooth adapter lost. Stopping all connections...\")\n                    await self._kill_all_connections()\n                    return\n\n                await asyncio.sleep(0.3)\n\n                await self._scanner_queue_routine()\n                await self._connection_queue_routine()\n                await self._check_device_types()\n                await self._remove_done_tasks()\n\n            except asyncio.TimeoutError:\n                continue\n            except Exception as e:\n                logger.exception(f\"Error in manager loop: {e}\")\n\n        await self._finish_all_connections()\n\n    async def _kill_all_connections(self) -&gt; None:\n        self._task_stop_event.set()\n\n        for serial in list(self._connections.keys()):\n            if not self._connections[serial][0].done():\n                logger.info(f\"Cancelling connection task {serial}.\")\n                self._connections[serial][0].cancel()\n            self._connections.pop(serial, None)\n            logger.info(f\"{serial}: Connection task cancelled and popped.\")\n\n    async def _finish_all_connections_blocking(self) -&gt; None:\n        while list(self._connections.keys()):\n            serial = list(self._connections.keys())[0]\n\n            if not self._connections[serial][0].done():\n                await asyncio.sleep(1)\n            else:\n                self._connections.pop(serial, None)\n\n    async def _finish_all_connections(self) -&gt; None:\n        self._task_stop_event.set()\n        await asyncio.sleep(1)  # give tasks some time to finish gracefully\n\n        # wait max 5s for _finish_all_connections_blocking to finish\n        try:\n            await asyncio.wait_for(self._finish_all_connections_blocking(), timeout=7)\n        except asyncio.TimeoutError:\n            logger.warning(\"Timeout waiting for connections to finish. Forcing cancellation.\")\n\n        for serial in list(self._connections.keys()):\n            if not self._connections[serial][0].done():\n                logger.warning(f\"Forcing connection task {serial} to cancel.\")\n                self._connections[serial][0].cancel()\n                await asyncio.sleep(0.1)  # small delay to allow cancellation to propagate\n                # logger.info(f\"Waiting for connection task {serial} to finish.\")\n                # await self._connections[serial]\n\n            self._connections.pop(serial, None)\n            logger.info(f\"{serial}: Connection task finished and popped.\")\n\n    async def _task_connection(self, device: BLEDevice, serial: int) -&gt; None:\n        try:\n            async with PartectorBleConnection(\n                device=device, loop=self._loop, serial_number=serial, queue=self._queue_connection\n            ):\n                while not self._task_stop_event.is_set():\n                    await asyncio.sleep(0.5)\n\n        except asyncio.CancelledError:\n            logger.info(f\"{serial}: Connection task cancelled.\")\n        except Exception as e:\n            logger.warning(f\"{serial}: Connection task failed: {e}\")\n        finally:\n            logger.info(f\"{serial}: Connection task finished.\")\n\n    async def _scanner_queue_routine(self) -&gt; None:\n        \"\"\"Process scanner queue with batch collection to reduce DataFrame operations.\n\n        Instead of calling add_data_point_to_dict for each item (expensive),\n        collect all items first, then add them in bulk.\n        \"\"\"\n        to_check: dict[int, BLEDevice] = {}\n        batch_data: list[NaneosDeviceDataPoint] = []\n\n        # Collect all available items from queue (non-blocking batch)\n        while not self._queue_scanner.empty():\n            try:\n                device, decoded = self._queue_scanner.get_nowait()\n            except asyncio.QueueEmpty:\n                break\n\n            if not decoded.serial_number:\n                continue\n\n            batch_data.append(decoded)\n            to_check[decoded.serial_number] = device\n\n        # Add all data points at once (more efficient than individual additions)\n        for decoded in batch_data:\n            self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, decoded)\n\n        # check for new devices\n        for serial, device in to_check.items():\n            if serial in self._connections:\n                continue  # already connected\n\n            logger.info(f\"New device detected: serial={serial}, address={device.address}\")\n            task = self._loop.create_task(self._task_connection(device, serial))\n            self._connections[serial] = (task, NaneosDeviceDataPoint.DEV_TYPE_P2)\n\n    async def _connection_queue_routine(self) -&gt; None:\n        \"\"\"Process connection queue with batch collection to reduce DataFrame operations.\n\n        Instead of calling add_data_point_to_dict for each item (expensive),\n        collect all items first, then add them in bulk.\n        \"\"\"\n        batch_data: list[NaneosDeviceDataPoint] = []\n\n        # Collect all available items from queue (non-blocking batch)\n        while not self._queue_connection.empty():\n            try:\n                data = self._queue_connection.get_nowait()\n            except asyncio.QueueEmpty:\n                break\n\n            batch_data.append(data)\n\n        # Add all data points at once (more efficient than individual additions)\n        for data in batch_data:\n            self._data = NaneosDeviceDataPoint.add_data_point_to_dict(self._data, data)\n\n    async def _check_device_types(self) -&gt; None:\n        for serial in self._data.keys():\n            if serial not in self._connections:\n                continue\n\n            current_type = self._connections[serial][1]\n            data_points = self._data[serial]\n\n            # get last value of device_type column\n            if data_points.empty:\n                continue\n            last_device_type = data_points[\"device_type\"].iloc[-1]\n            if last_device_type != current_type:\n                self._connections[serial] = (\n                    self._connections[serial][0],\n                    last_device_type,\n                )\n\n    async def _remove_done_tasks(self) -&gt; None:\n        \"\"\"Remove completed tasks from the connections dictionary.\"\"\"\n        for serial in list(self._connections.keys()):\n            if self._connections[serial][0].done():\n                self._connections.pop(serial, None)\n                logger.info(f\"{serial}: Connection task finished and popped.\")\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_manager/#naneos.partector_ble.partector_ble_manager.PartectorBleManager.get_connected_device_strings","title":"<code>get_connected_device_strings()</code>","text":"<p>Returns a list of connected device strings.</p> Source code in <code>src/naneos/partector_ble/partector_ble_manager.py</code> <pre><code>def get_connected_device_strings(self) -&gt; list[str]:\n    \"\"\"Returns a list of connected device strings.\"\"\"\n    # first make a copy to avoid runtime dict change issues\n    connections_copy = self._connections.copy()\n    sns = connections_copy.keys()\n    device_types = [connections_copy[s][1] for s in sns]\n\n    sns_list = []\n    for sn, dev_type in zip(sns, device_types):\n        if dev_type == NaneosDeviceDataPoint.DEV_TYPE_P2PRO:\n            sns_list.append(f\"SN{sn} (P2 Pro)\")\n    for sn, dev_type in zip(sns, device_types):\n        if dev_type == NaneosDeviceDataPoint.DEV_TYPE_P2:\n            sns_list.append(f\"SN{sn} (P2)\")\n\n    return sns_list\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_manager/#naneos.partector_ble.partector_ble_manager.PartectorBleManager.get_connected_serial_numbers","title":"<code>get_connected_serial_numbers()</code>","text":"<p>Returns a list of connected serial numbers.</p> Source code in <code>src/naneos/partector_ble/partector_ble_manager.py</code> <pre><code>def get_connected_serial_numbers(self) -&gt; list[int | None]:\n    \"\"\"Returns a list of connected serial numbers.\"\"\"\n    return list(self._connections.keys())\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_manager/#naneos.partector_ble.partector_ble_manager.PartectorBleManager.get_data","title":"<code>get_data()</code>","text":"<p>Returns the data dictionary and deletes it.</p> Source code in <code>src/naneos/partector_ble/partector_ble_manager.py</code> <pre><code>def get_data(self) -&gt; dict[int, pd.DataFrame]:\n    \"\"\"Returns the data dictionary and deletes it.\"\"\"\n    data = self._data\n    self._data = {}\n    return data\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/","title":"partector_ble_scanner","text":""},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner","title":"<code>naneos.partector_ble.partector_ble_scanner</code>","text":""},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner","title":"<code>PartectorBleScanner</code>","text":"<p>Context-managed BLE scanner for Partector devices.</p> <p>This scanner runs in the provided asyncio event loop and collects advertisement data from BLE devices named \"P2\" or \"PartectorBT\". Decoded advertisement payloads are pushed into an asyncio.Queue for further processing. Can be used with <code>async with</code> for automatic startup and cleanup.</p> Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>class PartectorBleScanner:\n    \"\"\"\n    Context-managed BLE scanner for Partector devices.\n\n    This scanner runs in the provided asyncio event loop and collects advertisement data\n    from BLE devices named \"P2\" or \"PartectorBT\". Decoded advertisement payloads are\n    pushed into an asyncio.Queue for further processing. Can be used with `async with`\n    for automatic startup and cleanup.\n    \"\"\"\n\n    SCAN_INTERVAL = 0.8  # seconds\n    BLE_NAMES_NANEOS = {\"P2\", \"PartectorBT\"}  # P2 on windows, PartectorBT on linux / mac\n\n    # static methods ###############################################################################\n    @staticmethod\n    def create_scanner_queue() -&gt; asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]]:\n        \"\"\"Create a queue for the scanner.\"\"\"\n        # Increased maxsize to 500 to handle bursts from multiple devices\n        # Prevents message loss on systems with many concurrent BLE connections\n        queue_scanner: asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]] = asyncio.Queue(\n            maxsize=500\n        )\n\n        return queue_scanner\n\n    # == Lifecycle and Context Management ==========================================================\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        queue: asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]],\n    ) -&gt; None:\n        \"\"\"\n        Initializes the scanner with the given event loop and queue.\n\n        Args:\n            loop (asyncio.AbstractEventLoop): The event loop to run the scanner in.\n            queue (asyncio.Queue): The queue to store the scanned data.\n        \"\"\"\n        self._loop = loop\n        self._queue = queue\n\n        self._task: asyncio.Task | None = None\n\n        self._stop_event = asyncio.Event()\n        self._stop_event.set()  # stopped by default\n\n    async def __aenter__(self) -&gt; PartectorBleScanner:\n        self.start()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        await self.stop()\n\n    # == Public Methods ============================================================================\n    def start(self) -&gt; None:\n        \"\"\"Starts the scanner.\"\"\"\n        if not self._stop_event.is_set():\n            logger.warning(\"You called PartectorBleScanner.start() but scanner is already running.\")\n            return\n\n        logger.debug(\"Starting PartectorBleScanner...\")\n        self._stop_event.clear()\n        self._task = self._loop.create_task(self.scan())\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stops the scanner.\"\"\"\n        logger.debug(\"Stopping PartectorBleScanner...\")\n        self._stop_event.set()\n        if self._task and not self._task.done():\n            await self._task\n        logger.info(\"PartectorBleScanner stopped.\")\n\n    # == Internal Async Processing =================================================================\n    async def _detection_callback(self, device: BLEDevice, adv: AdvertisementData) -&gt; None:\n        \"\"\"Handles the callbacks from the BleakScanner used in the scan method.\n\n        Args:\n            device (BLEDevice): Bleak BLEDevice object\n            adv (AdvertisementData): Bleak AdvertisementData object\n        \"\"\"\n\n        if not device.name or device.name not in self.BLE_NAMES_NANEOS:\n            return\n\n        adv_data = PartectorBleDecoder.decode_partector_advertisement(adv)\n        if not adv_data:\n            return\n\n        decoded = PartectorBleDecoderStd.decode(adv_data[0], data_structure=None)\n        if not decoded.serial_number:\n            return\n        if adv_data[1]:\n            decoded = PartectorBleDecoderAux.decode(adv_data[1], data_structure=decoded)\n        decoded.unix_timestamp = int(time.time()) * 1000\n        decoded.connection_type = NaneosDeviceDataPoint.CONN_TYPE_ADVERTISEMENT\n\n        # Non-blocking put with overflow handling: drop oldest item if queue is full\n        # This prevents callbacks from being delayed by queue operations\n        try:\n            if self._queue.full():\n                try:\n                    self._queue.get_nowait()  # Remove oldest item\n                except asyncio.QueueEmpty:\n                    pass\n            self._queue.put_nowait((device, decoded))\n        except asyncio.QueueFull:\n            logger.debug(f\"Scanner queue full, dropping advertisement from {device.address}\")\n\n    async def scan(self) -&gt; None:\n        \"\"\"Scans for BLE devices and calls the _detection_callback method for each device found.\"\"\"\n\n        scanner = BleakScanner(self._detection_callback)\n\n        while not self._stop_event.is_set():\n            try:\n                async with scanner:\n                    await asyncio.sleep(self.SCAN_INTERVAL)\n            except Exception as e:\n                logger.exception(e)\n                await asyncio.sleep(self.SCAN_INTERVAL)  # small backoff before retry\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner.__init__","title":"<code>__init__(loop, queue)</code>","text":"<p>Initializes the scanner with the given event loop and queue.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>AbstractEventLoop</code> <p>The event loop to run the scanner in.</p> required <code>queue</code> <code>Queue</code> <p>The queue to store the scanned data.</p> required Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>def __init__(\n    self,\n    loop: asyncio.AbstractEventLoop,\n    queue: asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]],\n) -&gt; None:\n    \"\"\"\n    Initializes the scanner with the given event loop and queue.\n\n    Args:\n        loop (asyncio.AbstractEventLoop): The event loop to run the scanner in.\n        queue (asyncio.Queue): The queue to store the scanned data.\n    \"\"\"\n    self._loop = loop\n    self._queue = queue\n\n    self._task: asyncio.Task | None = None\n\n    self._stop_event = asyncio.Event()\n    self._stop_event.set()  # stopped by default\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner.create_scanner_queue","title":"<code>create_scanner_queue()</code>  <code>staticmethod</code>","text":"<p>Create a queue for the scanner.</p> Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>@staticmethod\ndef create_scanner_queue() -&gt; asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]]:\n    \"\"\"Create a queue for the scanner.\"\"\"\n    # Increased maxsize to 500 to handle bursts from multiple devices\n    # Prevents message loss on systems with many concurrent BLE connections\n    queue_scanner: asyncio.Queue[tuple[BLEDevice, NaneosDeviceDataPoint]] = asyncio.Queue(\n        maxsize=500\n    )\n\n    return queue_scanner\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner.scan","title":"<code>scan()</code>  <code>async</code>","text":"<p>Scans for BLE devices and calls the _detection_callback method for each device found.</p> Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>async def scan(self) -&gt; None:\n    \"\"\"Scans for BLE devices and calls the _detection_callback method for each device found.\"\"\"\n\n    scanner = BleakScanner(self._detection_callback)\n\n    while not self._stop_event.is_set():\n        try:\n            async with scanner:\n                await asyncio.sleep(self.SCAN_INTERVAL)\n        except Exception as e:\n            logger.exception(e)\n            await asyncio.sleep(self.SCAN_INTERVAL)  # small backoff before retry\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner.start","title":"<code>start()</code>","text":"<p>Starts the scanner.</p> Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the scanner.\"\"\"\n    if not self._stop_event.is_set():\n        logger.warning(\"You called PartectorBleScanner.start() but scanner is already running.\")\n        return\n\n    logger.debug(\"Starting PartectorBleScanner...\")\n    self._stop_event.clear()\n    self._task = self._loop.create_task(self.scan())\n</code></pre>"},{"location":"reference/naneos/partector_ble/partector_ble_scanner/#naneos.partector_ble.partector_ble_scanner.PartectorBleScanner.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stops the scanner.</p> Source code in <code>src/naneos/partector_ble/partector_ble_scanner.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stops the scanner.\"\"\"\n    logger.debug(\"Stopping PartectorBleScanner...\")\n    self._stop_event.set()\n    if self._task and not self._task.done():\n        await self._task\n    logger.info(\"PartectorBleScanner stopped.\")\n</code></pre>"},{"location":"reference/naneos/protobuf/","title":"protobuf","text":""},{"location":"reference/naneos/protobuf/#naneos.protobuf","title":"<code>naneos.protobuf</code>","text":""},{"location":"reference/naneos/protobuf/protoV1_pb2/","title":"protoV1_pb2","text":""},{"location":"reference/naneos/protobuf/protoV1_pb2/#naneos.protobuf.protoV1_pb2","title":"<code>naneos.protobuf.protoV1_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"reference/naneos/protobuf/protobuf/","title":"protobuf","text":""},{"location":"reference/naneos/protobuf/protobuf/#naneos.protobuf.protobuf","title":"<code>naneos.protobuf.protobuf</code>","text":""},{"location":"reference/naneos/serial_utils/","title":"serial_utils","text":""},{"location":"reference/naneos/serial_utils/#naneos.serial_utils","title":"<code>naneos.serial_utils</code>","text":""},{"location":"reference/naneos/serial_utils/list_serial_ports/","title":"list_serial_ports","text":""},{"location":"reference/naneos/serial_utils/list_serial_ports/#naneos.serial_utils.list_serial_ports","title":"<code>naneos.serial_utils.list_serial_ports</code>","text":""},{"location":"reference/naneos/serial_utils/list_serial_ports/#naneos.serial_utils.list_serial_ports.list_serial_ports","title":"<code>list_serial_ports(ports_exclude=[])</code>","text":"<p>Returns a list of serial ports available on the system.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the platform is not supported.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of serial ports available on the system.</p> Source code in <code>src/naneos/serial_utils/list_serial_ports.py</code> <pre><code>def list_serial_ports(ports_exclude: list = []) -&gt; list[str]:\n    \"\"\"Returns a list of serial ports available on the system.\n\n    Raises:\n        OSError: If the platform is not supported.\n\n    Returns:\n        list[str]: A list of serial ports available on the system.\n    \"\"\"\n    # ports: list[str] = _get_all_open_ports()\n    ports: list[str] = _get_all_dosemet_ports(ports_exclude)\n    ports = _check_port_function(ports)\n\n    return ports\n</code></pre>"}]}